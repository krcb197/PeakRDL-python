"""
peakrdl-python is a tool to generate Python Register Access Layer (RAL) from SystemRDL
Copyright (C) 2021 - 2025

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.

This package is intended to distributed as part of automatically generated code by the PeakRDL
Python tool. It provide the base class for the autogenerated tests
"""
# this module is very similar to the non-async version, a lot of code has been put into common
# methods but it did not make sense to do everything as it would destroy readability
# pylint:disable=duplicate-code

import unittest
from abc import ABC
from typing import Union
from unittest.mock import patch
from itertools import product

from ..lib import FieldAsyncReadOnly, FieldAsyncWriteOnly, FieldAsyncReadWrite
from ..lib import FieldEnumAsyncReadOnly, FieldEnumAsyncWriteOnly, FieldEnumAsyncReadWrite
from ..sim_lib.dummy_callbacks import async_dummy_read
from ..sim_lib.dummy_callbacks import async_dummy_write


from .utilities import reverse_bits, expected_reg_write_data
from .utilities import reg_value_for_field_read_with_random_base
from .utilities import random_field_value, random_field_parent_reg_value

from ._common_base_test_class import CommonTestBase

class AsyncLibTestBase(unittest.IsolatedAsyncioTestCase, CommonTestBase, ABC):
    """
    Base Test class for the autogenerated register test when in async mode
    """

    # The following may look odd by a second layer of indirection is required to effectively patch
    # the read and write within tests

    # pylint:disable=missing-function-docstring

    async def outer_read_callback(self, addr: int, width: int, accesswidth: int) -> int:
        return await self.read_callback(addr=addr,
                                        width=width,
                                        accesswidth=accesswidth)

    async def read_callback(self, addr: int, width: int, accesswidth: int) -> int:
        return await  async_dummy_read(addr=addr,
                                       width=width,
                                       accesswidth=accesswidth)

    async def outer_write_callback(self, addr: int,
                                   width: int, accesswidth: int,
                                   data: int) -> None:
        return await self.write_callback(addr=addr,
                                         width=width,
                                         accesswidth=accesswidth,
                                         data=data)

    async def write_callback(self, addr: int, width: int, accesswidth: int, data: int) -> None:
        return await  async_dummy_write(addr=addr,
                                        width=width,
                                        accesswidth=accesswidth,
                                        data=data)

    # pylint:enable=missing-function-docstring


    async def _single_int_field_read_and_write_test(
            self,
            fut: Union[FieldAsyncReadOnly, FieldAsyncWriteOnly, FieldAsyncReadWrite],
            is_sw_readable: bool,
            is_sw_writable: bool) -> None:

        # the lsb, msb, high, low, bitmask, inv_bitmask and max_value are all checked as part of
        # `test_field_properties` so do no need to checked here. Similarly, the properties of
        # parent register are checked as part of `test_register_properties`

        if is_sw_readable:
            if not isinstance(fut, (FieldAsyncReadOnly, FieldAsyncReadWrite)):
                raise TypeError('Test can not proceed as the fut is not a readable field')
            await self.__single_field_read_test(fut=fut)

        if is_sw_writable:
            if not isinstance(fut, (FieldAsyncWriteOnly, FieldAsyncReadWrite)):
                raise TypeError('Test can not proceed as the fut is not a writable field')
            await self.__single_field_write_test(fut=fut)

    async def __single_field_read_test(
            self,
            fut: Union[FieldAsyncReadOnly, FieldAsyncReadWrite]) -> None:

        with patch.object(self,'write_callback') as write_callback_mock, \
            patch.object(self,'read_callback', return_value=0) as read_callback_mock:

            # read back - zero, this is achieved by setting the register to inverse bitmask
            read_callback_mock.return_value = fut.inverse_bitmask
            self.assertEqual(await fut.read(),0)
            read_callback_mock.assert_called_once_with(
                addr=fut.parent_register.address,
                width=fut.parent_register.width,
                accesswidth=fut.parent_register.accesswidth)

            # read back - max_value, this is achieved by setting the register to bitmask
            read_callback_mock.reset_mock()
            read_callback_mock.return_value = fut.bitmask
            self.assertEqual(await fut.read(), fut.max_value)
            read_callback_mock.assert_called_once_with(
                addr=fut.parent_register.address,
                width=fut.parent_register.width,
                accesswidth=fut.parent_register.accesswidth)

            # read back - random value
            read_callback_mock.reset_mock()
            random_value = random_field_parent_reg_value(fut)
            read_callback_mock.return_value = random_value
            field_value = (random_value & fut.bitmask) >> fut.low
            if fut.msb == fut.high:
                self.assertEqual(await fut.read(), field_value)
            else:
                self.assertEqual(await fut.read(),
                                 reverse_bits(value=field_value, number_bits=fut.width))
            read_callback_mock.assert_called_once_with(
                addr=fut.parent_register.address,
                width=fut.parent_register.width,
                accesswidth=fut.parent_register.accesswidth)

            # at the end of the read tests the write should not have been called
            read_callback_mock.reset_mock()
            write_callback_mock.assert_not_called()

    async def __single_field_write_test(
            self,
            fut: Union[FieldAsyncWriteOnly, FieldAsyncReadWrite]) -> None:

        with patch.object(self, 'write_callback') as write_callback_mock, \
                patch.object(self, 'read_callback', return_value=0) as read_callback_mock:

            # pylint:disable-next=protected-access
            readable_reg = fut.parent_register._is_readable

            for reg_base_value, field_value in product(
                    [0, fut.parent_register.max_value, random_field_parent_reg_value(fut)],
                    [0, fut.max_value, random_field_value(fut)]):
                read_callback_mock.reset_mock()
                write_callback_mock.reset_mock()
                read_callback_mock.return_value = reg_base_value

                await fut.write(field_value)

                if (fut.width < fut.parent_register.width) and readable_reg:
                    read_callback_mock.assert_called_once_with(
                        addr=fut.parent_register.address,
                        width=fut.parent_register.width,
                        accesswidth=fut.parent_register.accesswidth)
                else:
                    read_callback_mock.assert_not_called()

                write_callback_mock.assert_called_once_with(
                    addr=fut.parent_register.address,
                    width=fut.parent_register.width,
                    accesswidth=fut.parent_register.accesswidth,
                    data=expected_reg_write_data(fut=fut,
                                                 reg_base_value=reg_base_value,
                                                 readable_reg=readable_reg,
                                                 field_value=field_value))


                # check invalid write values bounce
                with self.assertRaises(ValueError):
                    await fut.write(fut.max_value + 1)

                with self.assertRaises(ValueError):
                    await fut.write(-1)

    async def __single_enum_field_read_test(self,
                                      fut: Union[FieldEnumAsyncReadOnly, FieldEnumAsyncReadOnly],
                                      enum_definition: dict[str, int],
                                      ) -> None:

        # pylint does not realise this is a class being returned rather than an object, so
        # is unhappy with the name
        #pylint:disable-next=invalid-name
        EnumCls = fut.enum_cls

        with patch.object(self, 'write_callback') as write_callback_mock, \
                patch.object(self, 'read_callback', return_value=0) as read_callback_mock:

            # read back - each legal enum value
            for enum_name, enum_value in enum_definition.items():
                read_callback_mock.reset_mock()
                reg_value = reg_value_for_field_read_with_random_base(fut=fut,
                                                                      field_value= enum_value)
                read_callback_mock.return_value = reg_value
                self.assertEqual(await fut.read(), EnumCls[enum_name])
                read_callback_mock.assert_called_once_with(
                    addr=fut.parent_register.address,
                    width=fut.parent_register.width,
                    accesswidth=fut.parent_register.accesswidth)

            # check register values that don't map to a legal enum value create an exception
            # this check is only relevant if there are potential field values that do not map to
            # the enum
            if len(enum_definition) < (2**fut.width):
                # there are two versions of this:
                # 1) for small fields (up to 8 bit wide) every value is tested
                # 2) for large fields (typically occurring with a sparse enum 100 values are
                #    checked
                legal_enum_values_set = set(enum_definition.values())
                if fut.width <= 8:
                    bad_field_value_iter = set(range(fut.max_value+1))
                else:
                    bad_field_value_iter = {random_field_value(fut) for _ in range(100)}

                for bad_field_value in bad_field_value_iter - legal_enum_values_set:
                    read_callback_mock.reset_mock()
                    reg_value = reg_value_for_field_read_with_random_base(
                        fut=fut,
                        field_value=bad_field_value)
                    read_callback_mock.return_value = reg_value
                    with self.assertRaises(ValueError):
                        _ = await fut.read()
                    read_callback_mock.assert_called_once_with(
                        addr=fut.parent_register.address,
                        width=fut.parent_register.width,
                        accesswidth=fut.parent_register.accesswidth)

            # at the end of the read tests the write should not have been called
            write_callback_mock.assert_not_called()

    async def __single_enum_field_write_test(self,
                                      fut: Union[FieldEnumAsyncWriteOnly, FieldEnumAsyncReadWrite],
                                      enum_definition: dict[str, int]) -> None:
        # pylint does not realise this is a class being returned rather than an object, so
        # is unhappy with the name
        # pylint:disable-next=invalid-name
        EnumCls = fut.enum_cls

        # pylint:disable-next=protected-access
        readable_reg = fut.parent_register._is_readable

        with patch.object(self, 'write_callback') as write_callback_mock, \
                patch.object(self, 'read_callback', return_value=0) as read_callback_mock:

            for enum_name, enum_value in enum_definition.items():
                random_reg_value = random_field_parent_reg_value(fut)
                read_callback_mock.return_value = random_reg_value
                await fut.write(EnumCls[enum_name])

                # the read is skipped if the register is not readable or has the same width
                # as the field
                if (fut.width < fut.parent_register.width) and readable_reg:
                    read_callback_mock.assert_called_once_with(
                        addr=fut.parent_register.address,
                        width=fut.parent_register.width,
                        accesswidth=fut.parent_register.accesswidth)
                else:
                    read_callback_mock.assert_not_called()

                write_callback_mock.assert_called_once_with(
                    addr=fut.parent_register.address,
                    width=fut.parent_register.width,
                    accesswidth=fut.parent_register.accesswidth,
                    data=expected_reg_write_data(fut=fut,
                                                 reg_base_value=random_reg_value,
                                                 readable_reg=readable_reg,
                                                 field_value=enum_value))

                read_callback_mock.reset_mock()
                write_callback_mock.reset_mock()

    async def _single_enum_field_read_and_write_test(
            self,
            fut: Union[FieldEnumAsyncReadOnly, FieldEnumAsyncReadOnly, FieldEnumAsyncWriteOnly],
            enum_definition: dict[str, int],
            is_sw_readable: bool,
            is_sw_writable: bool) -> None:
        """
        Check the ability to read and write to integer (non-encoded) field
        """

        # the lsb, msb, high, low, bitmask, inv_bitmask and max_value are all checked as part of
        # `test_field_properties` so do not need to checked here. Similarly, the properties of
        # parent register are checked as part of `test_register_properties`

        if is_sw_readable:
            if not isinstance(fut, (FieldEnumAsyncReadOnly, FieldEnumAsyncReadWrite)):
                raise TypeError('Test can not proceed as the fut is not a readable field')
            await self.__single_enum_field_read_test(fut=fut,
                                               enum_definition=enum_definition)

        if is_sw_writable:
            if not isinstance(fut, (FieldEnumAsyncWriteOnly, FieldEnumAsyncReadWrite)):
                raise TypeError('Test can not proceed as the fut is not a writable field')
            await self.__single_enum_field_write_test(fut=fut,
                                                enum_definition=enum_definition)

"""
peakrdl-python is a tool to generate Python Register Access Layer (RAL) from SystemRDL
Copyright (C) 2021 - 2025

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.

This package is intended to distributed as part of automatically generated code by the PeakRDL
Python tool. It provide the base class for the autogenerated tests
"""
import unittest
from abc import ABC
from typing import Union
import random
from unittest.mock import patch
from itertools import product

from ..lib import FieldReadWrite, FieldReadOnly, FieldWriteOnly
from ..lib import RegReadOnly, RegReadWrite, RegWriteOnly
from ..sim_lib.dummy_callbacks import dummy_read
from ..sim_lib.dummy_callbacks import dummy_write

from .utilities import reverse_bits, expected_reg_write_data
from .utilities import random_reg_value

class LibTestBase(unittest.TestCase, ABC):
    """
    Base Test class for the autogenerated register test when in async mode
    """

    # The following may look odd by a second layer of indirection is required to effectively patch
    # the read and write within tests

    # pylint:disable=missing-function-docstring

    def outer_read_callback(self, addr: int, width: int, accesswidth: int) -> int:
        return self.read_callback(addr=addr, width=width, accesswidth=accesswidth)

    def read_callback(self, addr: int, width: int, accesswidth: int) -> int:
        return dummy_read(addr=addr, width=width, accesswidth=accesswidth)

    def outer_write_callback(self, addr: int, width: int, accesswidth: int,  data: int) -> None:
        return self.write_callback(addr=addr, width=width, accesswidth=accesswidth, data=data)

    def write_callback(self, addr: int, width: int, accesswidth: int,  data: int) -> None:
        return dummy_write(addr=addr, width=width, accesswidth=accesswidth, data=data)

    # pylint:enable=missing-function-docstring

    def __single_field_read_test(self, fut: Union[FieldReadOnly, FieldReadOnly]) -> None:

        with patch.object(self, 'write_callback') as write_callback_mock, \
                patch.object(self, 'read_callback', return_value=0) as read_callback_mock:

            # read back - zero, this is achieved by setting the register to inverse bitmask
            read_callback_mock.return_value = fut.inverse_bitmask
            self.assertEqual(fut.read(), 0)
            read_callback_mock.assert_called_once_with(
                addr=fut.parent_register.address,
                width=fut.parent_register.width,
                accesswidth=fut.parent_register.accesswidth)

            # read back - max_value, this is achieved by setting the register to bitmask
            read_callback_mock.reset_mock()
            read_callback_mock.return_value = fut.bitmask
            self.assertEqual(fut.read(), fut.max_value)
            read_callback_mock.assert_called_once_with(
                addr=fut.parent_register.address,
                width=fut.parent_register.width,
                accesswidth=fut.parent_register.accesswidth)

            # read back - random value
            read_callback_mock.reset_mock()
            random_value = random.randrange(0, fut.parent_register.max_value + 1)
            read_callback_mock.return_value = random_value
            random_field_value = (random_value & fut.bitmask) >> fut.low
            if fut.msb == fut.high:
                self.assertEqual(fut.read(), random_field_value)
            else:
                self.assertEqual(fut.read(),
                                 reverse_bits(value=random_field_value, number_bits=fut.width))
            read_callback_mock.assert_called_once_with(
                addr=fut.parent_register.address,
                width=fut.parent_register.width,
                accesswidth=fut.parent_register.accesswidth)

            # at the end of the read tests the write should not have been called
            write_callback_mock.assert_not_called()

    def __single_field_write_test(self, fut: Union[FieldReadOnly, FieldWriteOnly]) -> None:

        # pylint:disable-next=protected-access
        readable_reg = fut.parent_register._is_readable

        with patch.object(self, 'write_callback') as write_callback_mock, \
                patch.object(self, 'read_callback', return_value=0) as read_callback_mock:
            if not isinstance(fut, (FieldWriteOnly, FieldReadWrite)):
                raise TypeError('Test can not proceed as the fut is not a writable field')

            random_reg_value = random.randrange(0, fut.parent_register.max_value + 1)
            random_field_value = random.randrange(0, fut.max_value + 1)
            for reg_base_value,field_value in product(
                    [0, fut.parent_register.max_value, random_reg_value],
                    [0, fut.max_value, random_field_value]):
                read_callback_mock.reset_mock()
                write_callback_mock.reset_mock()
                read_callback_mock.return_value = reg_base_value

                fut.write(field_value)

                # special case if the field is the full size of the register, the read is skipped
                # similarly, if the register is not readable it is skipped
                if (fut.width < fut.parent_register.width) and readable_reg:
                    read_callback_mock.assert_called_once_with(
                        addr=fut.parent_register.address,
                        width=fut.parent_register.width,
                        accesswidth=fut.parent_register.accesswidth)
                else:
                    read_callback_mock.assert_not_called()

                write_callback_mock.assert_called_once_with(
                    addr=fut.parent_register.address,
                    width=fut.parent_register.width,
                    accesswidth=fut.parent_register.accesswidth,
                    data=expected_reg_write_data(fut=fut,
                                                 reg_base_value=reg_base_value,
                                                 readable_reg=readable_reg,
                                                 field_value=field_value))

            # check invalid write values bounce
            with self.assertRaises(ValueError):
                fut.write(fut.max_value + 1)

            with self.assertRaises(ValueError):
                fut.write(-1)

    def _single_int_field_read_and_write_test(
            self,
            fut: Union[FieldReadOnly, FieldReadOnly, FieldWriteOnly],
            is_sw_readable: bool,
            is_sw_writable: bool) -> None:
        """
        Check the ability to read and write to integer (non-encoded) field
        """

        # the lsb, msb, high, low, bitmask, inv_bitmask and max_value are all checked as part of
        # `test_field_properties` so do not need to checked here. Similarly, the properties of
        # parent register are checked as part of `test_register_properties`

        if is_sw_readable:
            if not isinstance(fut, (FieldReadOnly, FieldReadWrite)):
                raise TypeError('Test can not proceed as the fut is not a readable field')
            self.__single_field_read_test(fut=fut)

        if is_sw_writable:
            if not isinstance(fut, (FieldWriteOnly, FieldReadWrite)):
                raise TypeError('Test can not proceed as the fut is not a writable field')
            self.__single_field_write_test(fut=fut)

    def _single_register_read_and_write_test(self,
                                             rut: Union[RegReadOnly, RegReadWrite, RegWriteOnly],
                                             has_sw_readable: bool,
                                             has_sw_writable: bool) -> None:

        # the register properties are tested separately so are available to be used here

        if has_sw_readable:
            if not isinstance(rut, (RegReadOnly, RegReadWrite)):
                raise TypeError('Test can not proceed as the fut is not a readable field')
            self.__single_reg_read_test(rut=rut)
        else:
            # test that a non-readable register has no read method and
            # attempting one generates and error
            with self.assertRaises(AttributeError):
                _= rut.read(0)  # type: ignore[union-attr,call-arg]

        if has_sw_writable:
            if not isinstance(rut, (RegWriteOnly, RegReadWrite)):
                raise TypeError('Test can not proceed as the fut is not a writable field')
            self.__single_reg_write_test(rut=rut)
        else:
            # test that a non-writable register has no write method and
            # attempting one generates and error
            with self.assertRaises(AttributeError):
                rut.write(0)  # type: ignore[union-attr,call-arg]

    def __single_reg_read_test(self, rut: Union[RegReadOnly, RegReadWrite]) -> None:

        with patch.object(self, 'write_callback') as write_callback_mock, \
                patch.object(self, 'read_callback', return_value=1) as read_callback_mock:
            for reg_value in [0, 1, rut.max_value, random_reg_value(rut)]:
                read_callback_mock.reset_mock()
                read_callback_mock.return_value = reg_value
                self.assertEqual(rut.read(), reg_value)
                read_callback_mock.assert_called_once_with(
                    addr=rut.address,
                    width=rut.width,
                    accesswidth=rut.accesswidth)
            write_callback_mock.assert_not_called()

    def __single_reg_write_test(self, rut: Union[RegWriteOnly, RegReadWrite]) -> None:
        with patch.object(self, 'write_callback') as write_callback_mock, \
                patch.object(self, 'read_callback', return_value=0) as read_callback_mock:
            for reg_value in [0, 1, rut.max_value, random_reg_value(rut)]:
                write_callback_mock.reset_mock()
                read_callback_mock.return_value = reg_value
                rut.write(reg_value)
                write_callback_mock.assert_called_once_with(
                    addr=rut.address,
                    width=rut.width,
                    accesswidth=rut.accesswidth,
                    data=reg_value)
            read_callback_mock.assert_not_called()

            # test writing a value beyond the register range is blocked with an exception being raised
            with self.assertRaises(ValueError):
                rut.write(-1)

            with self.assertRaises(ValueError):
                rut.write(rut.max_value + 1)

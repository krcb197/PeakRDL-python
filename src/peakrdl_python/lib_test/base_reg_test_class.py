"""
peakrdl-python is a tool to generate Python Register Access Layer (RAL) from SystemRDL
Copyright (C) 2021 - 2025

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.

This package is intended to distributed as part of automatically generated code by the PeakRDL
Python tool. It provide the base class for the autogenerated tests
"""
import unittest
from abc import ABC
from typing import Union
import random
from unittest.mock import patch
from itertools import product

from ..lib import FieldReadWrite, FieldReadOnly, FieldWriteOnly
from ..sim_lib.dummy_callbacks import dummy_read
from ..sim_lib.dummy_callbacks import dummy_write

from .utilities import reverse_bits, expected_reg_write_data

class LibTestBase(unittest.TestCase, ABC):
    """
    Base Test class for the autogenerated register test when in async mode
    """

    # The following may look odd by a second layer of indirection is required to effectively patch
    # the read and write within tests

    # pylint:disable=missing-function-docstring

    def outer_read_callback(self, addr: int, width: int, accesswidth: int) -> int:
        return self.read_callback(addr=addr, width=width, accesswidth=accesswidth)

    def read_callback(self, addr: int, width: int, accesswidth: int) -> int:
        return dummy_read(addr=addr, width=width, accesswidth=accesswidth)

    def outer_write_callback(self, addr: int, width: int, accesswidth: int,  data: int) -> None:
        return self.write_callback(addr=addr, width=width, accesswidth=accesswidth, data=data)

    def write_callback(self, addr: int, width: int, accesswidth: int,  data: int) -> None:
        return dummy_write(addr=addr, width=width, accesswidth=accesswidth, data=data)

    # pylint:enable=missing-function-docstring

    def __single_field_read_test(self, fut: Union[FieldReadOnly, FieldReadOnly]) -> None:

        with patch.object(self, 'write_callback') as write_callback_mock, \
                patch.object(self, 'read_callback', return_value=0) as read_callback_mock:

            # read back - zero, this is achieved by setting the register to inverse bitmask
            read_callback_mock.return_value = fut.inverse_bitmask
            self.assertEqual(fut.read(), 0)
            read_callback_mock.assert_called_once_with(
                addr=fut.parent_register.address,
                width=fut.parent_register.width,
                accesswidth=fut.parent_register.accesswidth)

            # read back - max_value, this is achieved by setting the register to bitmask
            read_callback_mock.reset_mock()
            read_callback_mock.return_value = fut.bitmask
            self.assertEqual(fut.read(), fut.max_value)
            read_callback_mock.assert_called_once_with(
                addr=fut.parent_register.address,
                width=fut.parent_register.width,
                accesswidth=fut.parent_register.accesswidth)

            # read back - random value
            read_callback_mock.reset_mock()
            random_value = random.randrange(0, fut.parent_register.max_value + 1)
            read_callback_mock.return_value = random_value
            random_field_value = (random_value & fut.bitmask) >> fut.low
            if fut.msb == fut.high:
                self.assertEqual(fut.read(), random_field_value)
            else:
                self.assertEqual(fut.read(),
                                 reverse_bits(value=random_field_value, number_bits=fut.width))
            read_callback_mock.assert_called_once_with(
                addr=fut.parent_register.address,
                width=fut.parent_register.width,
                accesswidth=fut.parent_register.accesswidth)

            # at the end of the read tests the write should not have been called
            write_callback_mock.assert_not_called()

    def __single_field_write_test(self, fut: Union[FieldReadOnly, FieldWriteOnly]) -> None:

        # pylint:disable-next=protected-access
        readable_reg = fut.parent_register._is_readable

        with patch.object(self, 'write_callback') as write_callback_mock, \
                patch.object(self, 'read_callback', return_value=0) as read_callback_mock:
            if not isinstance(fut, (FieldWriteOnly, FieldReadWrite)):
                raise TypeError('Test can not proceed as the fut is not a writable field')

            random_reg_value = random.randrange(0, fut.parent_register.max_value + 1)
            random_field_value = random.randrange(0, fut.max_value + 1)
            for reg_base_value,field_value in product(
                    [0, fut.parent_register.max_value, random_reg_value],
                    [0, fut.max_value, random_field_value]):
                read_callback_mock.reset_mock()
                write_callback_mock.reset_mock()
                read_callback_mock.return_value = reg_base_value

                fut.write(field_value)

                # special case if the field is the full size of the register, the read is skipped
                # similarly, if the register is not readable it is skipped
                if (fut.width < fut.parent_register.width) and readable_reg:
                    read_callback_mock.assert_called_once_with(
                        addr=fut.parent_register.address,
                        width=fut.parent_register.width,
                        accesswidth=fut.parent_register.accesswidth)
                else:
                    read_callback_mock.assert_not_called()

                write_callback_mock.assert_called_once_with(
                    addr=fut.parent_register.address,
                    width=fut.parent_register.width,
                    accesswidth=fut.parent_register.accesswidth,
                    data=expected_reg_write_data(fut=fut,
                                                 reg_base_value=reg_base_value,
                                                 readable_reg=readable_reg,
                                                 field_value=field_value))

            # check invalid write values bounce
            with self.assertRaises(ValueError):
                fut.write(fut.max_value + 1)

            with self.assertRaises(ValueError):
                fut.write(-1)

    def _single_int_field_read_and_write_test(
            self,
            fut: Union[FieldReadOnly, FieldReadOnly, FieldWriteOnly],
            is_sw_readable: bool,
            is_sw_writable: bool) -> None:
        """
        Check the ability to read and write to integer (non-encoded) field
        """

        # the lsb, msb, high, low, bitmask, inv_bitmask and max_value are all checked as part of
        # `test_field_properties` so do not need to checked here. Similarly, the properties of
        # parent register are checked as part of `test_register_properties`

        if is_sw_readable:
            if not isinstance(fut, (FieldReadOnly, FieldReadWrite)):
                raise TypeError('Test can not proceed as the fut is not a readable field')
            self.__single_field_read_test(fut=fut)

        if is_sw_writable:
            if not isinstance(fut, (FieldWriteOnly, FieldReadWrite)):
                raise TypeError('Test can not proceed as the fut is not a writable field')
            self.__single_field_write_test(fut=fut)

{#
peakrdl-python is a tool to generate Python Register Access Layer (RAL) from SystemRDL
Copyright (C) 2021 - 2025

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation, either version 3 of
the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
#}

{% include "header_tb.py.jinja" with context %}

{% from 'template_ultilities.py.jinja' import peakrdl_python_lib with context %}
{% from 'template_ultilities.py.jinja' import peakrdl_python_lib_test with context %}
{# the following defining the number relative steps up to the lib and sim_lib packages from the current file #}
{% set lib_depth = 1 %}

from typing import Union,Iterable
from array import array as Array
{% if asyncoutput %}
import asyncio
import unittest
from unittest.mock import patch, call
{% else %}
import unittest
from unittest.mock import patch, call
{% endif %}
import random
from itertools import combinations, chain
import math
{% if legacy_enum_type %}
from enum import IntEnum
{% endif %}

from {{ peakrdl_python_lib(depth=lib_depth) }} import UnsupportedWidthError

from ..reg_model import RegModel
from ..reg_model.{{top_node.inst_name}}_property_enums import *

{% if asyncoutput %}
from {{ peakrdl_python_lib(depth=lib_depth) }} import FieldAsyncReadOnly, FieldAsyncWriteOnly, FieldAsyncReadWrite
from {{ peakrdl_python_lib(depth=lib_depth) }} import RegAsyncReadWrite, RegAsyncReadOnly, RegAsyncWriteOnly
from {{ peakrdl_python_lib(depth=lib_depth) }} import RegAsyncReadWriteArray, RegAsyncReadOnlyArray, RegAsyncWriteOnlyArray
from {{ peakrdl_python_lib(depth=lib_depth) }} import MemoryAsyncReadOnly{% if legacy_block_access %}Legacy{% endif %}, MemoryAsyncWriteOnly{% if legacy_block_access %}Legacy{% endif %}, MemoryAsyncReadWrite{% if legacy_block_access %}Legacy{% endif %}
from {{ peakrdl_python_lib(depth=lib_depth) }} import MemoryAsyncReadOnly{% if legacy_block_access %}Legacy{% endif %}Array, MemoryAsyncWriteOnly{% if legacy_block_access %}Legacy{% endif %}Array, MemoryAsyncReadWrite{% if legacy_block_access %}Legacy{% endif %}Array
from {{ peakrdl_python_lib(depth=lib_depth) }} import AsyncAddressMap, AsyncRegFile
from {{ peakrdl_python_lib(depth=lib_depth) }} import AsyncAddressMapArray, AsyncRegFileArray
from {{ peakrdl_python_lib(depth=lib_depth) }} import AsyncMemory
{% else %}
from {{ peakrdl_python_lib(depth=lib_depth) }} import FieldReadOnly, FieldWriteOnly, FieldReadWrite
from {{ peakrdl_python_lib(depth=lib_depth) }} import RegReadWrite, RegReadOnly, RegWriteOnly
from {{ peakrdl_python_lib(depth=lib_depth) }} import RegReadWriteArray, RegReadOnlyArray, RegWriteOnlyArray
from {{ peakrdl_python_lib(depth=lib_depth) }} import MemoryReadOnly{% if legacy_block_access %}Legacy{% endif %}, MemoryWriteOnly{% if legacy_block_access %}Legacy{% endif %}, MemoryReadWrite{% if legacy_block_access %}Legacy{% endif %}
from {{ peakrdl_python_lib(depth=lib_depth) }} import MemoryReadOnly{% if legacy_block_access %}Legacy{% endif %}Array, MemoryWriteOnly{% if legacy_block_access %}Legacy{% endif %}Array, MemoryReadWrite{% if legacy_block_access %}Legacy{% endif %}Array
from {{ peakrdl_python_lib(depth=lib_depth) }} import AddressMap, RegFile
from {{ peakrdl_python_lib(depth=lib_depth) }} import AddressMapArray, RegFileArray
from {{ peakrdl_python_lib(depth=lib_depth) }} import Memory
{% endif %}

from {{ peakrdl_python_lib(depth=lib_depth) }} import NodeArray
from {{ peakrdl_python_lib(depth=lib_depth) }} import Field
from {{ peakrdl_python_lib(depth=lib_depth) }} import Reg
{% if not legacy_enum_type %}
from {{ peakrdl_python_lib(depth=lib_depth) }} import SystemRDLEnum, SystemRDLEnumEntry
{% endif %}
from {{ peakrdl_python_lib_test(depth=lib_depth) }} import reverse_bits
from {{ peakrdl_python_lib_test(depth=lib_depth) }} import NodeIterators

from ._{{top_node.inst_name}}_test_base import {{top_node.inst_name}}_TestCase, {{top_node.inst_name}}_TestCase_BlockAccess, {{top_node.inst_name}}_TestCase_AltBlockAccess
from ._{{top_node.inst_name}}_test_base import __name__ as base_name
from ._{{top_node.inst_name}}_test_base import random_enum_reg_value

{% from 'addrmap_udp_property.py.jinja' import udp_property_dict_entry with context %}

class {{fq_block_name}}_single_access({{top_node.inst_name}}_TestCase): # type: ignore[valid-type,misc]

    def test_field_encoding_properties(self)  -> None:
        """
        Check that enumeration has the name and desc meta data from the systemRDL
        """
        {% for node in owned_elements.fields -%}
            {% if 'encode' in node.list_properties() %}
        with self.subTest(msg='field: {{'.'.join(node.get_path_segments())}}'):
            # test properties of field: {{'.'.join(node.get_path_segments())}}
                {% for encoding_entry in node.get_property('encode') %}
            self.assertEqual(self.dut.{{'.'.join(get_python_path_segments(node))}}.enum_cls.{{encoding_entry.name | upper}}.value, {{encoding_entry.value}})
                    {% if not legacy_enum_type %}
                        {% if encoding_entry.rdl_name is none %}
            self.assertIsNone(self.dut.{{'.'.join(get_python_path_segments(node))}}.enum_cls.{{encoding_entry.name | upper}}.rdl_name)
                        {% else %}
            self.assertEqual(self.dut.{{'.'.join(get_python_path_segments(node))}}.enum_cls.{{encoding_entry.name | upper}}.rdl_name, {{encoding_entry.rdl_name | tojson}})
                        {% endif %}
                        {% if encoding_entry.rdl_desc is none %}
            self.assertIsNone(self.dut.{{'.'.join(get_python_path_segments(node))}}.enum_cls.{{encoding_entry.name | upper}}.rdl_desc)
                        {% else %}
            self.assertEqual(self.dut.{{'.'.join(get_python_path_segments(node))}}.enum_cls.{{encoding_entry.name | upper}}.rdl_desc, {{encoding_entry.rdl_desc | tojson}})
                        {% endif %}
                    {% endif %}
                {% endfor %}
            {% endif %}
        {% endfor %}

    def test_user_defined_properties(self)  -> None:
        """
        Walk the address map and check user defined properties are correctly pulled up
        """
        {% for node in owned_elements.nodes -%}
        with self.subTest(msg='register: {{'.'.join(node.get_path_segments())}}'):
            {% set property_list = get_properties_to_include(node,udp_include_func) %}
            {% if not property_list %}
            self.assertDictEqual(self.dut.{{'.'.join(get_python_path_segments(node))}}.udp,{})
            {% else %}
                {% for property_name in property_list %}
                {% set property_value = node.get_property(property_name) %}
                    {% if isinstance(property_value, systemrdlUserStruct) %}
            self.assertDictEqual(self.dut.{{'.'.join(get_python_path_segments(node))}}.udp['{{property_name}}'], {    # type: ignore[arg-type]
            {% for sub_name, sub_value in property_value.members.items() %} {{udp_property_dict_entry(sub_name, sub_value)}} {% endfor %}
                } )
                    {% elif isinstance(property_value, systemrdlUserEnum) %}
            self.assertEqual(self.dut.{{'.'.join(get_python_path_segments(node))}}.udp['{{property_name}}'], {{ type(property_value).type_name }}_property_enumcls.{{ property_value.name.upper() }} )
                     {% elif isinstance(property_value, str) %}
            self.assertEqual(self.dut.{{'.'.join(get_python_path_segments(node))}}.udp['{{property_name}}'], "{{ property_value }}" )
                    {% else %}
            self.assertEqual(self.dut.{{'.'.join(get_python_path_segments(node))}}.udp['{{property_name}}'], {{ property_value }} )
                    {% endif %}
                {% endfor %}
            {% endif %}
        {% endfor %}

    {% if uses_memory %}
    {% if asyncoutput %}async {% endif %}def test_memory(self) -> None:
        """
        Walk the memory instances in the register map and check:
        - the properties
        - it can be read and written to correctly
        """
        {% for node in owned_elements.memories -%}
        with self.subTest(msg='memory: {{'.'.join(node.get_path_segments())}}'):
            self._single_memory_property_test(mut=self.dut.{{'.'.join(get_python_path_segments(node))}}, address={{node.absolute_address}}, width={{node.get_property('memwidth')}}, entries={{node.get_property('mementries')}}, accesswidth={% if 'accesswidth' in node.list_properties() -%}{{node.get_property('accesswidth')}}{% else %}None{%- endif %}, array_typecode={% if legacy_block_access %}'{{get_array_typecode(node.get_property('memwidth'))}}'{% else %}None{% endif %}, size={{node.size}},
                                              rdl_name={% if skip_systemrdl_name_and_desc_properties %}None{% elif node.get_property('name', default=None) is none %}None{% else %}{{node.get_property('name') | tojson}}{% endif %},
                                              rdl_desc={% if skip_systemrdl_name_and_desc_properties %}None{% elif node.get_property('desc', default=None) is none %}None{% else %}{{node.get_property('desc') | tojson}}{% endif %},
                                              inst_name='{{node.get_path_segments()[-1]}}',
                                              parent_full_inst_name='{{'.'.join(node.get_path_segments()[:-1])}}')
            {% if asyncoutput %}await {%endif %}self._single_memory_read_and_write_test(mut=self.dut.{{'.'.join(get_python_path_segments(node))}}, is_sw_readable={{node.is_sw_readable}}, is_sw_writable={{node.is_sw_writable}},
                                                                                        writeable_registers=NodeIterators( {%- for child_node in node.children(unroll=False) %}{%- if not hide_node_func(child_node) %}{%- if isinstance(child_node, systemrdlRegNode) %}{% if child_node.has_sw_writable %}{{node_iterator_entry(child_node)}},{% endif %}{% endif %}{% endif %}{% endfor %}),
                                                                                        readable_registers=NodeIterators( {%- for child_node in node.children(unroll=False) %}{%- if not hide_node_func(child_node) %}{%- if isinstance(child_node, systemrdlRegNode) %}{% if child_node.has_sw_readable %}{{node_iterator_entry(child_node)}},{% endif %}{% endif %}{% endif %}{% endfor %}))
        {% endfor %}
    {% endif %} {# end if memory #}

    {% if asyncoutput %}async {% endif %}def test_register(self) -> None:
        """
        Walk the registers in the register map and check:
        - the properties
        - it can be read and written to correctly
        """
        {% for node in owned_elements.registers -%}
        with self.subTest(msg='register: {{'.'.join(node.get_path_segments())}}'):
            self._single_register_property_test(rut=self.dut.{{'.'.join(get_python_path_segments(node))}}, address={{node.absolute_address}}, width={{node.size * 8}}, accesswidth={% if 'accesswidth' in node.list_properties() -%}{{node.get_property('accesswidth')}}{% else %}None{%- endif %}, size={{node.size}},
                                                rdl_name={% if skip_systemrdl_name_and_desc_properties %}None{% elif node.get_property('name', default=None) is none %}None{% else %}{{node.get_property('name') | tojson}}{% endif %},
                                                rdl_desc={% if skip_systemrdl_name_and_desc_properties %}None{% elif node.get_property('desc', default=None) is none %}None{% else %}{{node.get_property('desc') | tojson}}{% endif %},
                                                inst_name='{{node.get_path_segments()[-1]}}',
                                                parent_full_inst_name='{{'.'.join(node.get_path_segments()[:-1])}}')
            {% if asyncoutput %}await {%endif %}self._single_register_read_and_write_test(rut=self.dut.{{'.'.join(get_python_path_segments(node))}}, has_sw_readable={{node.has_sw_readable}}, has_sw_writable={{node.has_sw_writable}},
                                                                                          readable_fields=set([ {%- for child_node in node.children(unroll=True) -%}{%- if not hide_node_func(child_node) -%}{% if isinstance(child_node, systemrdlFieldNode) %}{% if child_node.is_sw_readable %}'{{child_node.inst_name}}',{% endif %}{% endif %}{% endif %}{% endfor %} ]),
                                                                                          writeable_fields=set([ {%- for child_node in node.children(unroll=True) -%}{%- if not hide_node_func(child_node) -%}{% if isinstance(child_node, systemrdlFieldNode) %}{% if child_node.is_sw_writable %}'{{child_node.inst_name}}',{% endif %}{% endif %}{% endif %}{% endfor %} ]) )
        {% endfor %}

    {% if asyncoutput %}async {% endif %}def test_field(self) -> None:
        """
        Check the properties and function (read and write) on the fields both integer and enum
        """
        {% for node in owned_elements.fields %}
        with self.subTest(msg='field: {{'.'.join(node.get_path_segments())}}'):
            self._single_field_property_test(fut=self.dut.{{'.'.join(get_python_path_segments(node))}}, lsb={{node.lsb}}, msb={{node.msb}}, low={{node.low}}, high={{node.high}}, is_volatile={{node.is_hw_writable}}, default={{get_field_default_value(node)}},
                                             rdl_name={% if skip_systemrdl_name_and_desc_properties %}None{% elif node.get_property('name', default=None) is none %}None{% else %}{{node.get_property('name') | tojson}}{% endif %},
                                             rdl_desc={% if skip_systemrdl_name_and_desc_properties %}None{% elif node.get_property('desc', default=None) is none %}None{% else %}{{node.get_property('desc') | tojson}}{% endif %},
                                             inst_name='{{node.get_path_segments()[-1]}}',
                                             parent_full_inst_name='{{'.'.join(node.get_path_segments()[:-1])}}')
            {%- if 'encode' not in node.list_properties() %}
            {% if asyncoutput %}await {%endif %}self._single_int_field_read_and_write_test(fut=self.dut.{{'.'.join(get_python_path_segments(node))}}, is_sw_readable={{node.is_sw_readable}}, is_sw_writable={{node.is_sw_writable}})
            {%- else %}
            {% if asyncoutput %}await {%endif %}self._single_enum_field_read_and_write_test(fut=self.dut.{{'.'.join(get_python_path_segments(node))}}, # type: ignore[arg-type]
                                                                                            is_sw_readable={{node.is_sw_readable}}, is_sw_writable={{node.is_sw_writable}}, enum_definition={ {% for enum_entry in node.get_property('encode') %}'{{enum_entry.name.upper()}}':{{enum_entry.value}},{% endfor %} })
            {%- endif %}
        {%- endfor %}

    def test_addrmap(self) -> None:
        """
        Check the properties on the addrmaps files
        """

        {% if block == top_node %}
        with self.subTest(msg='addrmap: top_node'):
            self._single_addrmap_property_test(dut=self.dut,
                                               size={{block.size}},
                                               rdl_name={% if skip_systemrdl_name_and_desc_properties %}None{% elif top_node.get_property('name', default=None) is none %}None{% else %}{{top_node.get_property('name') | tojson}}{% endif %},
                                               rdl_desc={% if skip_systemrdl_name_and_desc_properties %}None{% elif top_node.get_property('desc', default=None) is none %}None{% else %}{{top_node.get_property('desc') | tojson}}{% endif %},
                                               inst_name='{{top_node.get_path_segments()[-1]}}',
                                               parent_full_inst_name=None)
            self._test_addrmap_iterators(dut=self.dut,
                                         writeable_registers=NodeIterators({%- for child_node in top_node.children(unroll=False) %}{%- if not hide_node_func(child_node) %}{%- if isinstance(child_node, systemrdlRegNode) %}{% if child_node.has_sw_writable %}{{node_iterator_entry(child_node)}},{% endif %}{% endif %}{% endif %}{% endfor %}),
                                         readable_registers=NodeIterators({%- for child_node in top_node.children(unroll=False) %}{%- if not hide_node_func(child_node) %}{%- if isinstance(child_node, systemrdlRegNode) %}{% if child_node.has_sw_readable %}{{node_iterator_entry(child_node)}},{% endif %}{% endif %}{% endif %}{% endfor %}),
                                         sections=NodeIterators({%- for child_node in top_node.children(unroll=False) %}{%- if not hide_node_func(child_node) %}{%- if isinstance(child_node, (systemrdlRegfileNode,systemrdlAddrmapNode)) %}{{node_iterator_entry(child_node)}},{% endif %}{% endif %}{% endfor %}),
                                         memories=NodeIterators({%- for child_node in top_node.children(unroll=False) %}{%- if not hide_node_func(child_node) %}{%- if isinstance(child_node, systemrdlMemNode) %}{{node_iterator_entry(child_node)}},{% endif %}{% endif %}{% endfor %}))
        {% endif %}{# if block == top_block #}


        # test all the address maps
        {% for node in owned_elements.addr_maps -%}
        with self.subTest(msg='addrmap: {{'.'.join(node.get_path_segments())}}'):
            self._single_addrmap_property_test(dut=self.dut.{{'.'.join(get_python_path_segments(node))}},
                                               size={{node.size}},
                                               rdl_name={% if skip_systemrdl_name_and_desc_properties %}None{% elif node.get_property('name', default=None) is none %}None{% else %}{{node.get_property('name') | tojson}}{% endif %},
                                               rdl_desc={% if skip_systemrdl_name_and_desc_properties %}None{% elif node.get_property('desc', default=None) is none %}None{% else %}{{node.get_property('desc') | tojson}}{% endif %},
                                               inst_name='{{node.get_path_segments()[-1]}}',
                                               parent_full_inst_name='{{'.'.join(node.get_path_segments()[:-1])}}')
            self._test_addrmap_iterators(dut=self.dut.{{'.'.join(get_python_path_segments(node))}},
                                         writeable_registers=NodeIterators( {%- for child_node in node.children(unroll=False) %}{%- if not hide_node_func(child_node) %}{%- if isinstance(child_node, systemrdlRegNode) %}{% if child_node.has_sw_writable %}{{node_iterator_entry(child_node)}},{% endif %}{% endif %}{% endif %}{% endfor %}),
                                         readable_registers=NodeIterators( {%- for child_node in node.children(unroll=False) %}{%- if not hide_node_func(child_node) %}{%- if isinstance(child_node, systemrdlRegNode) %}{% if child_node.has_sw_readable %}{{node_iterator_entry(child_node)}},{% endif %}{% endif %}{% endif %}{% endfor %}),
                                         sections=NodeIterators( {%- for child_node in node.children(unroll=False) %}{%- if not hide_node_func(child_node) %}{%- if isinstance(child_node, (systemrdlRegfileNode,systemrdlAddrmapNode)) %}{{node_iterator_entry(child_node)}},{% endif %}{% endif %}{% endfor %}),
                                         memories=NodeIterators( {%- for child_node in node.children(unroll=False) %}{%- if not hide_node_func(child_node) %}{%- if isinstance(child_node, systemrdlMemNode) %}{{node_iterator_entry(child_node)}},{% endif %}{% endif %}{% endfor %}))
        {% endfor %}

    def test_regfile(self) -> None:
        """
        Check the properties on the register files
        """

        # test all the register files
        {% for node in owned_elements.reg_files -%}
        with self.subTest(msg='regfile: {{'.'.join(node.get_path_segments())}}'):
            self._single_regfile_property_test(dut=self.dut.{{'.'.join(get_python_path_segments(node))}},
                                               size={{node.size}},
                                               rdl_name={% if skip_systemrdl_name_and_desc_properties %}None{% elif node.get_property('name', default=None) is none %}None{% else %}{{node.get_property('name') | tojson}}{% endif %},
                                               rdl_desc={% if skip_systemrdl_name_and_desc_properties %}None{% elif node.get_property('desc', default=None) is none %}None{% else %}{{node.get_property('desc') | tojson}}{% endif %},
                                               inst_name='{{node.get_path_segments()[-1]}}',
                                               parent_full_inst_name='{{'.'.join(node.get_path_segments()[:-1])}}')
            self._test_regfile_iterators(dut=self.dut.{{'.'.join(get_python_path_segments(node))}},
                                         writeable_registers=NodeIterators({%- for child_node in node.children(unroll=False) %}{%- if not hide_node_func(child_node) %}{%- if isinstance(child_node, systemrdlRegNode) %}{% if child_node.has_sw_writable %}{{node_iterator_entry(child_node)}},{% endif %}{% endif %}{% endif %}{% endfor %}),
                                         readable_registers=NodeIterators({%- for child_node in node.children(unroll=False) %}{%- if not hide_node_func(child_node) %}{%- if isinstance(child_node, systemrdlRegNode) %}{% if child_node.has_sw_readable %}{{node_iterator_entry(child_node)}},{% endif %}{% endif %}{% endif %}{% endfor %}),
                                         sections=NodeIterators({%- for child_node in node.children(unroll=False) %}{%- if not hide_node_func(child_node) %}{%- if isinstance(child_node, (systemrdlRegfileNode,systemrdlAddrmapNode)) %}{{node_iterator_entry(child_node)}},{% endif %}{% endif %}{% endfor %}))
        {% endfor %}

    {% if owned_elements.has_hidden_nodes %}
    def test_hidden(self) -> None:
        """
        Check that any 1st layer hidden node is not present
        """
        {% for node in owned_elements.hidden_nodes -%}
        with self.subTest(msg='hidden_node: {{'.'.join(node.get_path_segments())}}'):
            {% if node.parent ==  top_node %}
            with self.assertRaises(KeyError):
                self.dut.get_child_by_system_rdl_name('{{node.inst_name}}')
            {% else %}
            with self.assertRaises(KeyError):
                self.dut.{{'.'.join(get_python_path_segments(node.parent))}}.get_child_by_system_rdl_name('{{node.inst_name}}') # type: ignore[call-overload]
            {% endif %}
            with self.assertRaises(AttributeError):
                _ = self.dut.{{'.'.join(get_python_path_segments(node))}} # type: ignore[attr-defined]
        {% endfor %}
    {% endif %}

    def test_array_slicing(self) -> None:
        """
        Check slicing into array
        """
        full_slice:NodeArray
        {% for node in rolled_owned_array %}
        with self.subTest(msg='hidden_node: {{'.'.join(node.get_path_segments())}}'):
            {% if node.parent ==  top_node %}
            full_slice = self.dut.get_child_by_system_rdl_name('{{node.inst_name}}')
            {% else %}
            full_slice = self.dut.{{'.'.join(get_python_path_segments(node.parent))}}.get_child_by_system_rdl_name('{{node.inst_name}}')
            {% endif %}
            self.assertCountEqual(iter(full_slice{{full_slice_accessor(node)}}), iter(full_slice))
        {% endfor %}



class {{fq_block_name}}_block_access({{top_node.inst_name}}_TestCase_BlockAccess): # type: ignore[valid-type,misc]
    """
    tests for all the block access methods
    """

    {% if uses_memory %}
    {% if asyncoutput %}async {% endif %}def test_memory_read_and_write(self) -> None:
        """
        Walk the register map and check every register can be read and written to correctly
        """
        {% for node in owned_elements.memories -%}

        # test access operations (read and/or write) to register:
        # {{'.'.join(node.get_path_segments())}}
        with patch(base_name + '.write_addr_space') as write_callback_mock,\
                            patch(base_name + '.read_addr_space', return_value=1) as read_callback_mock, \
                            patch(base_name + '.read_block_addr_space',
                                  return_value={% if legacy_block_access %}Array('{{get_array_typecode(node.get_property('memwidth'))}}', [0]){% else %}[0]{% endif %}) as read_block_callback_mock , \
                            patch(base_name + '.write_block_addr_space') as write_block_callback_mock:

            {% if node.is_sw_readable -%}
            # checks single unit accesses at the first entry, the last entry and a random entry in
            # in each case check a 0, max value and random value being read
            for entry in [0, random.randint(0,{{node.get_property('mementries')-1}}), {{node.get_property('mementries')-1}}]:
                for value in [0, random.randint(0,{{get_memory_max_entry_value_hex_string(node)}}), {{get_memory_max_entry_value_hex_string(node)}}]:
                    read_block_callback_mock.reset_mock()
                    {% if legacy_block_access %}
                    read_block_callback_mock.return_value = Array('{{get_array_typecode(node.get_property('memwidth'))}}',
                                                                  [value])
                    {% else %}
                    read_block_callback_mock.return_value = [value]
                    {% endif %}

                    {% if legacy_block_access %}
                    self.assertEqual({% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.read(start_entry=entry, number_entries=1), # type: ignore[union-attr]
                                                             Array('{{get_array_typecode(node.get_property('memwidth'))}}', [value]))
                    {% else %}
                    self.assertEqual({% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.read(start_entry=entry, number_entries=1), # type: ignore[union-attr]
                                                             [value])
                    {% endif %}
                    read_block_callback_mock.assert_called_once_with(
                                        addr={{node.absolute_address}}+(entry * {{get_memory_width_bytes(node)}}),
                                        width={{node.get_property('memwidth')}},
                                        accesswidth={{node.get_property('memwidth')}},
                                        length=1)

            # check a multi-entry read, if the memory is small do the entire memory, however, if
            # it is large limit the number of entries to 10
            entries_to_test = {% if node.get_property('mementries') > 10 %}10{% else %}{{node.get_property('mementries')}}{% endif %}
            {% if legacy_block_access %}
            random_data = Array('{{get_array_typecode(node.get_property('memwidth'))}}',
                                [random.randint(0,{{get_memory_max_entry_value_hex_string(node)}}) for x in range(entries_to_test)])
            {% else %}
            random_data = [random.randint(0,{{get_memory_max_entry_value_hex_string(node)}}) for x in range(entries_to_test)]
            {% endif %}


            read_block_callback_mock.reset_mock()
            read_block_callback_mock.return_value = random_data

            self.assertEqual({% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.read(start_entry=0, # type: ignore[union-attr]
                                          number_entries=entries_to_test),
                                          random_data)

            write_callback_mock.assert_not_called()
            read_callback_mock.assert_not_called()
            write_block_callback_mock.assert_not_called()
            read_block_callback_mock.reset_mock()
            {% endif %}

            {% if node.is_sw_writable -%}
            # checks single unit accesses at the first entry, the last entry and a random entry in
            # in each case check a 0, max value and random value being read
            for entry in [0, random.randint(0,{{node.get_property('mementries')-1}}), {{node.get_property('mementries')-1}}]:
                for value in [0, random.randint(0,{{get_memory_max_entry_value_hex_string(node)}}), {{get_memory_max_entry_value_hex_string(node)}}]:
                    write_block_callback_mock.reset_mock()
                    {% if legacy_block_access %}
                    {% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.write(start_entry=entry, data=Array('{{get_array_typecode(node.get_property('memwidth'))}}', [value])) # type: ignore[union-attr]
                    write_block_callback_mock.assert_called_once_with(
                                        addr={{node.absolute_address}}+(entry * {{get_memory_width_bytes(node)}}),
                                        width={{node.get_property('memwidth')}},
                                        accesswidth={{node.get_property('memwidth')}},
                                        data=Array('{{get_array_typecode(node.get_property('memwidth'))}}', [value]))
                    {% else %}
                    {% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.write(start_entry=entry, data=[value]) # type: ignore[union-attr]
                    write_block_callback_mock.assert_called_once_with(
                                        addr={{node.absolute_address}}+(entry * {{get_memory_width_bytes(node)}}),
                                        width={{node.get_property('memwidth')}},
                                        accesswidth={{node.get_property('memwidth')}},
                                        data=[value])
                    {% endif %}


            read_callback_mock.assert_not_called()
            write_callback_mock.assert_not_called()
            read_block_callback_mock.assert_not_called()
            write_block_callback_mock.reset_mock()

            # check a multi-entry read, if the memory is small do the entire memory, however, if
            # it is large limit the number of entries to 10
            entries_to_test = {% if node.get_property('mementries') > 10 %}10{% else %}{{node.get_property('mementries')}}{% endif %}
            {% if legacy_block_access %}
            random_data = Array('{{get_array_typecode(node.get_property('memwidth'))}}',
                                [random.randint(0,{{get_memory_max_entry_value_hex_string(node)}}) for x in range(entries_to_test)])
            {% else %}
            random_data = [random.randint(0,{{get_memory_max_entry_value_hex_string(node)}}) for x in range(entries_to_test)]
            {% endif %}
            {% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.write(start_entry=0, data=random_data) # type: ignore[union-attr]

            write_block_callback_mock.assert_called_once_with(
                                        addr={{node.absolute_address}},
                                        width={{node.get_property('memwidth')}},
                                        accesswidth={{node.get_property('memwidth')}},
                                        data=random_data)

            read_callback_mock.assert_not_called()
            write_callback_mock.assert_not_called()
            read_block_callback_mock.assert_not_called()
            write_block_callback_mock.reset_mock()

            {%- endif %}

        {%- endfor %}
    {%- endif %}

    {% if asyncoutput %}async {% endif %}def test_register_array_context_manager(self) -> None:
        """
        Walk the register map and check that register map context managers work correctly
        """
        {% for node in rolled_owned_reg_array %}
        # test context manager to register:
        # {{'.'.join(node.get_path_segments())}}
        # size {{node.size}}
        # total_size {{node.total_size}}
        empty_read = [0 for i in range({{node.total_size}} // {{node.size}})]
        follow_along = [0 for i in range({{node.total_size}} // {{node.size}})]
        with self.subTest(msg='register: {{'.'.join(node.get_path_segments())}}'):
            with patch(base_name + '.write_addr_space') as write_callback_mock,\
                                patch(base_name + '.read_addr_space', return_value=0) as read_callback_mock, \
                                patch(base_name + '.read_block_addr_space',
                                      return_value={% if legacy_block_access %}Array('{{get_array_typecode(node.size * 8)}}', empty_read){% else %}empty_read{% endif %}) as read_block_callback_mock , \
                                patch(base_name + '.write_block_addr_space') as write_block_callback_mock:
                {% if node.has_sw_readable and node.has_sw_writable -%}
                {% if asyncoutput %}async {% endif %}with self.dut.{{'.'.join(get_python_path_segments(node))}}.single_read_modify_write() as dut:
                    pass
                {% elif not node.has_sw_readable and node.has_sw_writable-%}
                {% if asyncoutput %}async {% endif %}with self.dut.{{'.'.join(get_python_path_segments(node))}}.single_write() as dut:
                    pass
                read_block_callback_mock.assert_not_called()
                {% elif node.has_sw_readable and not node.has_sw_writable-%}
                {% if asyncoutput %}async {% endif %}with self.dut.{{'.'.join(get_python_path_segments(node))}}.single_read() as dut:
                    pass
                write_block_callback_mock.assert_not_called()
                {% endif %}
                read_callback_mock.assert_not_called()
                write_callback_mock.assert_not_called()

        {%- endfor %}

class {{fq_block_name}}_alt_block_access({{top_node.inst_name}}_TestCase_AltBlockAccess): # type: ignore[valid-type,misc]
    """
    tests for all the block access methods with the alternative callbacks, this is a simpler
    version of the tests above
    """
    {% if uses_memory %}
    {% if asyncoutput %}async {% endif %}def test_memory_read_and_write(self) -> None:
        """
        Walk the register map and check every register can be read and written to correctly
        """
        {% for node in owned_elements.memories -%}

        # test access operations (read and/or write) to register:
        # {{'.'.join(node.get_path_segments())}}
        entries_to_test = {% if node.get_property('mementries') > 10 %}10{% else %}{{node.get_property('mementries')}}{% endif %}
        {% if node.get_property('memwidth') not in [8, 16, 32, 64] and not legacy_block_access %}
            {% if node.is_sw_readable %}
        with self.assertRaises(UnsupportedWidthError):
            _ = {% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.read(start_entry=0, # type: ignore[union-attr]
                                      number_entries=entries_to_test)
            {% endif %}
        {% else %}
        with patch(base_name + '.write_addr_space') as write_callback_mock,\
                            patch(base_name + '.read_addr_space', return_value=1) as read_callback_mock, \
                            patch(base_name + '.read_block_addr_space_alt',
                                  return_value={% if not legacy_block_access %}Array('{{get_array_typecode(node.get_property('memwidth'))}}', [0]){% else %}[0]{% endif %}) as read_block_callback_mock , \
                            patch(base_name + '.write_block_addr_space_alt') as write_block_callback_mock:

            {% if node.is_sw_readable -%}
            random_data_list = [random.randint(0,{{get_memory_max_entry_value_hex_string(node)}}) for x in range(entries_to_test)]
            random_data_array = Array('{{get_array_typecode(node.get_property('memwidth'))}}', random_data_list)

            read_block_callback_mock.reset_mock()
            {% if not legacy_block_access %}
            read_block_callback_mock.return_value = random_data_array
            self.assertEqual({% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.read(start_entry=0, # type: ignore[union-attr]
                                          number_entries=entries_to_test),
                                          random_data_list)
            {% else %}
            read_block_callback_mock.return_value = random_data_list
            self.assertEqual({% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.read(start_entry=0, # type: ignore[union-attr]
                                          number_entries=entries_to_test),
                                          random_data_array)
            {% endif %}

            write_callback_mock.assert_not_called()
            read_callback_mock.assert_not_called()
            write_block_callback_mock.assert_not_called()
            read_block_callback_mock.reset_mock()
            {% endif %}

            {% if node.is_sw_writable -%}
            # check a multi-entry read, if the memory is small do the entire memory, however, if
            # it is large limit the number of entries to 10
            entries_to_test = {% if node.get_property('mementries') > 10 %}10{% else %}{{node.get_property('mementries')}}{% endif %}
            random_data_list = [random.randint(0,{{get_memory_max_entry_value_hex_string(node)}}) for x in range(entries_to_test)]
            random_data_array = Array('{{get_array_typecode(node.get_property('memwidth'))}}', random_data_list)
            {% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.write(start_entry=0, data={% if legacy_block_access %}random_data_array{% else %}random_data_list{% endif %}) # type: ignore[union-attr]

            write_block_callback_mock.assert_called_once_with(
                                        addr={{node.absolute_address}},
                                        width={{node.get_property('memwidth')}},
                                        accesswidth={{node.get_property('memwidth')}},
                                        data={% if not legacy_block_access %}random_data_array{% else %}random_data_list{% endif %})

            read_callback_mock.assert_not_called()
            write_callback_mock.assert_not_called()
            read_block_callback_mock.assert_not_called()
            write_block_callback_mock.reset_mock()

            {%- endif %}
        {% endif %}
        {%- endfor %}
    {%- endif %}

    {% if asyncoutput %}async {% endif %}def test_register_array_context_manager(self) -> None:
        """
        Walk the register map and check that register map context managers work correctly
        """
        {% for node in rolled_owned_reg_array %}
        # test context manager to register with alt block interfaces:
        # {{'.'.join(node.get_path_segments())}}
        # size {{node.size}}
        # total_size {{node.total_size}}
        {% if node.size > 8 and not legacy_block_access %}
        with self.assertRaises(UnsupportedWidthError):
            {% if node.has_sw_readable and node.has_sw_writable -%}
            {% if asyncoutput %}async {% endif %}with self.dut.{{'.'.join(get_python_path_segments(node))}}.single_read_modify_write() as dut:
                pass
            {% elif not node.has_sw_readable and node.has_sw_writable-%}
            {% if asyncoutput %}async {% endif %}with self.dut.{{'.'.join(get_python_path_segments(node))}}.single_write() as dut:
                pass
            read_block_callback_mock.assert_not_called()
            {% elif node.has_sw_readable and not node.has_sw_writable-%}
            {% if asyncoutput %}async {% endif %}with self.dut.{{'.'.join(get_python_path_segments(node))}}.single_read() as dut:
                pass
            write_block_callback_mock.assert_not_called()
            {% endif %}
        {% else %}
        empty_read = [0 for i in range({{node.total_size}} // {{node.size}})]
        follow_along = [0 for i in range({{node.total_size}} // {{node.size}})]
        with self.subTest(msg='register: {{'.'.join(node.get_path_segments())}}'):
            with patch(base_name + '.write_addr_space') as write_callback_mock,\
                            patch(base_name + '.read_addr_space', return_value=1) as read_callback_mock, \
                            patch(base_name + '.read_block_addr_space_alt',
                                  return_value={% if not legacy_block_access %}Array('{{get_array_typecode(node.size * 8)}}', empty_read){% else %}empty_read{% endif %}) as read_block_callback_mock , \
                            patch(base_name + '.write_block_addr_space_alt') as write_block_callback_mock:
                {% if node.has_sw_readable and node.has_sw_writable -%}
                {% if asyncoutput %}async {% endif %}with self.dut.{{'.'.join(get_python_path_segments(node))}}.single_read_modify_write() as dut:
                    pass
                {% elif not node.has_sw_readable and node.has_sw_writable-%}
                {% if asyncoutput %}async {% endif %}with self.dut.{{'.'.join(get_python_path_segments(node))}}.single_write() as dut:
                    pass
                read_block_callback_mock.assert_not_called()
                {% elif node.has_sw_readable and not node.has_sw_writable-%}
                {% if asyncoutput %}async {% endif %}with self.dut.{{'.'.join(get_python_path_segments(node))}}.single_read() as dut:
                    pass
                write_block_callback_mock.assert_not_called()
                {% endif %}
                read_callback_mock.assert_not_called()
                write_callback_mock.assert_not_called()
        {% endif %}
        {%- endfor %}


if __name__ == '__main__':

    unittest.main()

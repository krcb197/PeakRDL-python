{#
peakrdl-python is a tool to generate Python Register Access Layer (RAL) from SystemRDL
Copyright (C) 2021 - 2023

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
#}

{% include "header_tb.py.jinja" with context %}
from typing import Union
from array import array as Array
{% if asyncoutput %}
import sys
import asyncio
import unittest
from unittest.mock import patch, call
{% else %}
import unittest
from unittest.mock import patch, call
{% endif %}
import random
from itertools import combinations
import math
from enum import IntEnum

from {% if skip_lib_copy %}src.peakrdl_python.{% else %}..{% endif %}lib import RegisterWriteVerifyError, UnsupportedWidthError

from ..reg_model.{{top_node.inst_name}} import {{top_node.inst_name}}_cls
{% for property_enum in dependent_property_enum %}
from ..reg_model.{{top_node.inst_name}} import {{property_enum.type_name}}_property_enumcls
{% endfor %}


{% if asyncoutput %}
from {% if skip_lib_copy %}src.peakrdl_python.{% else %}..{% endif %}lib import FieldAsyncReadOnly, FieldAsyncWriteOnly, FieldAsyncReadWrite
from {% if skip_lib_copy %}src.peakrdl_python.{% else %}..{% endif %}lib import WritableAsyncRegister, ReadableAsyncRegister
from {% if skip_lib_copy %}src.peakrdl_python.{% else %}..{% endif %}lib import RegAsyncReadWrite, RegAsyncReadOnly, RegAsyncWriteOnly
from {% if skip_lib_copy %}src.peakrdl_python.{% else %}..{% endif %}lib import RegAsyncReadWriteArray, RegAsyncReadOnlyArray, RegAsyncWriteOnlyArray
from {% if skip_lib_copy %}src.peakrdl_python.{% else %}..{% endif %}lib import MemoryAsyncReadOnly{% if legacy_block_access %}Legacy{% endif %}, MemoryAsyncWriteOnly{% if legacy_block_access %}Legacy{% endif %}, MemoryAsyncReadWrite{% if legacy_block_access %}Legacy{% endif %}
from {% if skip_lib_copy %}src.peakrdl_python.{% else %}..{% endif %}lib import MemoryAsyncReadOnlyArray, MemoryAsyncWriteOnlyArray, MemoryAsyncReadWriteArray
from {% if skip_lib_copy %}src.peakrdl_python.{% else %}..{% endif %}lib import AsyncAddressMap, AsyncRegFile
from {% if skip_lib_copy %}src.peakrdl_python.{% else %}..{% endif %}lib import AsyncAddressMapArray, AsyncRegFileArray
from {% if skip_lib_copy %}src.peakrdl_python.{% else %}..{% endif %}lib import AsyncMemory
{% else %}
from {% if skip_lib_copy %}src.peakrdl_python.{% else %}..{% endif %}lib import FieldReadOnly, FieldWriteOnly, FieldReadWrite
from {% if skip_lib_copy %}src.peakrdl_python.{% else %}..{% endif %}lib import WritableRegister, ReadableRegister
from {% if skip_lib_copy %}src.peakrdl_python.{% else %}..{% endif %}lib import RegReadWrite, RegReadOnly, RegWriteOnly
from {% if skip_lib_copy %}src.peakrdl_python.{% else %}..{% endif %}lib import RegReadWriteArray, RegReadOnlyArray, RegWriteOnlyArray
from {% if skip_lib_copy %}src.peakrdl_python.{% else %}..{% endif %}lib import MemoryReadOnly{% if legacy_block_access %}Legacy{% endif %}, MemoryWriteOnly{% if legacy_block_access %}Legacy{% endif %}, MemoryReadWrite{% if legacy_block_access %}Legacy{% endif %}
from {% if skip_lib_copy %}src.peakrdl_python.{% else %}..{% endif %}lib import MemoryReadOnlyArray, MemoryWriteOnlyArray, MemoryReadWriteArray
from {% if skip_lib_copy %}src.peakrdl_python.{% else %}..{% endif %}lib import AddressMap, RegFile
from {% if skip_lib_copy %}src.peakrdl_python.{% else %}..{% endif %}lib import AddressMapArray, RegFileArray
from {% if skip_lib_copy %}src.peakrdl_python.{% else %}..{% endif %}lib import Memory
{% endif %}


from {% if skip_lib_copy %}src.peakrdl_python.{% else %}..{% endif %}lib import Field
from {% if skip_lib_copy %}src.peakrdl_python.{% else %}..{% endif %}lib import Reg

from ._{{top_node.inst_name}}_test_base import {{top_node.inst_name}}_TestCase, {{top_node.inst_name}}_TestCase_BlockAccess, {{top_node.inst_name}}_TestCase_AltBlockAccess
from ._{{top_node.inst_name}}_test_base import __name__ as base_name

{% from 'addrmap_udp_property.py.jinja' import udp_property_dict_entry with context %}

class {{fq_block_name}}_single_access({{top_node.inst_name}}_TestCase): # type: ignore[valid-type,misc]

    def test_inst_name(self)  -> None:
        """
        Walk the address map and check the inst name has been correctly populated
        """
        {% for node in owned_elements.nodes -%}
        with self.subTest(msg='node: {{'.'.join(node.get_path_segments())}}'):
            self.assertEqual(self.dut.{{'.'.join(get_python_path_segments(node))}}.inst_name, '{{node.get_path_segments()[-1]}}') # type: ignore[union-attr]
            self.assertEqual(self.dut.{{'.'.join(get_python_path_segments(node))}}.full_inst_name, '{{'.'.join(node.get_path_segments())}}')  # type: ignore[union-attr]
        {% endfor %}

    def test_sizes(self) -> None:
        """
        Check that the sizes all match
        """
        {% for node in owned_elements.addressable_nodes -%}
        with self.subTest(msg='node: {{'.'.join(node.get_path_segments())}}'):
            self.assertEqual(self.dut.{{'.'.join(get_python_path_segments(node))}}.size, {{node.size}}) # type: ignore[union-attr]
        {% endfor %}

        # check the size of the address map itself
        {% if block == top_node %}
        with self.subTest(msg='node: {{'.'.join(block.get_path_segments())}}'):
            self.assertEqual(self.dut.size, {{block.size}}) # type: ignore[union-attr]
        {% else %}
        with self.subTest(msg='node: {{'.'.join(block.get_path_segments())}}'):
            self.assertEqual(self.dut.{{'.'.join(get_python_path_segments(block))}}.size, {{block.size}}) # type: ignore[union-attr]
        {% endif %}


    def test_register_properties(self)  -> None:
        """
        Walk the address map and check the address, size and accesswidth of every register is
        correct
        """
        {% for node in owned_elements.registers -%}
        with self.subTest(msg='register: {{'.'.join(node.get_path_segments())}}'):
            self.assertEqual(self.dut.{{'.'.join(get_python_path_segments(node))}}.address, {{node.absolute_address}}) # type: ignore[union-attr]
            self.assertEqual(self.dut.{{'.'.join(get_python_path_segments(node))}}.width, {{node.size * 8}}) # type: ignore[union-attr]
            self.assertEqual(self.dut.{{'.'.join(get_python_path_segments(node))}}.size, {{node.size}}) # type: ignore[union-attr]
            {% if 'accesswidth' in node.list_properties() -%}self.assertEqual(self.dut.{{'.'.join(get_python_path_segments(node))}}.accesswidth, {{node.get_property('accesswidth')}}){%- else -%} self.assertEqual(self.dut.{{'.'.join(get_python_path_segments(node))}}.accesswidth, self.dut.{{'.'.join(get_python_path_segments(node))}}.accesswidth){%- endif %} # type: ignore[union-attr]
        {% endfor %}

    def test_memory_properties(self)  -> None:
        """
        Walk the address map and check the address, size and accesswidth of every memory is
        correct
        """
        mut: {% if asyncoutput %}Async{% endif %}Memory
        {% for node in owned_elements.memories -%}
        with self.subTest(msg='memory: {{'.'.join(node.get_path_segments())}}'):
            mut = self.dut.{{'.'.join(get_python_path_segments(node))}} # type: ignore[union-attr,assignment]

            self.assertIsInstance(mut, (Memory{% if asyncoutput %}Async{% endif %}ReadOnly{% if legacy_block_access %}Legacy{% endif %}, Memory{% if asyncoutput %}Async{% endif %}WriteOnly{% if legacy_block_access %}Legacy{% endif %}, Memory{% if asyncoutput %}Async{% endif %}ReadWrite{% if legacy_block_access %}Legacy{% endif %}))
            self.assertEqual(mut.address, {{node.absolute_address}})
            self.assertEqual(mut.width, {{node.get_property('memwidth')}})
            self.assertEqual(mut.entries, {{node.get_property('mementries')}})
            {% if 'accesswidth' in node.list_properties() -%}self.assertEqual(mut.accesswidth, {{node.get_property('accesswidth')}}){%- else -%}self.assertEqual(mut.accesswidth, mut.accesswidth){%- endif %}
        {% endfor %}

    def test_field_properties(self)  -> None:
        """
        walk the address map and check:
        - that the lsb and msb of every field is correct
        - that where default values are provided they are applied correctly
        """
        fut:Field
        {% for node in owned_elements.fields -%}
        with self.subTest(msg='field: {{'.'.join(node.get_path_segments())}}'):
            # test properties of field: {{'.'.join(node.get_path_segments())}}
            fut = self.dut.{{'.'.join(get_python_path_segments(node))}} # type: ignore[union-attr]
            if not isinstance(fut, Field):
                raise TypeError('This test relies on node being of type Field')
            self.assertEqual(fut.lsb,{{node.lsb}})
            self.assertEqual(fut.msb,{{node.msb}})
            self.assertEqual(fut.low,{{node.low}})
            self.assertEqual(fut.high,{{node.high}})
            self.assertEqual(fut.bitmask,{{get_field_bitmask_hex_string(node)}})
            self.assertEqual(fut.inverse_bitmask,{{get_field_inv_bitmask_hex_string(node)}})
            self.assertEqual(fut.max_value,{{get_field_max_value_hex_string(node)}})
                {% if 'encode' in node.list_properties() %}
                {# only attempt to test enum fields if the reset value is legal for the field #}
                    {% if get_field_default_value(node) in get_enum_values(node.get_property('encode')) %}
            self.assertEqual(fut.default,{{get_field_default_value(node)}})
                    {% else %}
            self.assertIsNone(fut.default)
                    {% endif %}
                {% else %}
            self.assertEqual(fut.default,{{get_field_default_value(node)}})
                {% endif %}
            self.assertEqual(fut.is_volatile,{{node.is_hw_writable}})
        {% endfor %}

    def test_user_defined_properties(self)  -> None:
        """
        Walk the address map and check user defined properties are correctly pulled up
        """
        {% for node in owned_elements.nodes -%}
        with self.subTest(msg='register: {{'.'.join(node.get_path_segments())}}'):
            {% if not udp_to_include %}
            self.assertDictEqual(self.dut.{{'.'.join(get_python_path_segments(node))}}.udp,{})
            {% else %}
                {% set property_list = get_properties_to_include(node,udp_to_include) %}
                {% if not property_list %}
            self.assertDictEqual(self.dut.{{'.'.join(get_python_path_segments(node))}}.udp,{})
                {% else %}
                    {% for property_name in property_list %}
                    {% set property_value = node.get_property(property_name) %}
                        {% if isinstance(property_value, systemrdlUserStruct) %}
            self.assertDictEqual(self.dut.{{'.'.join(get_python_path_segments(node))}}.udp['{{property_name}}'], {    # type: ignore[arg-type]
                {% for sub_name, sub_value in property_value.members.items() %} {{udp_property_dict_entry(sub_name, sub_value)}} {% endfor %}
                } )
                        {% elif isinstance(property_value, systemrdlUserEnum) %}
            self.assertEqual(self.dut.{{'.'.join(get_python_path_segments(node))}}.udp['{{property_name}}'], {{ type(property_value).type_name }}_property_enumcls.{{ property_value.name.upper() }} )
                         {% elif isinstance(property_value, str) %}
            self.assertEqual(self.dut.{{'.'.join(get_python_path_segments(node))}}.udp['{{property_name}}'], "{{ property_value }}" )
                        {% else %}
            self.assertEqual(self.dut.{{'.'.join(get_python_path_segments(node))}}.udp['{{property_name}}'], {{ property_value }} )
                        {% endif %}
                    {% endfor %}
                {% endif %}
            {% endif %}
        {% endfor %}

    {% if asyncoutput %}async {% endif %}def test_register_read_and_write(self) -> None:
        """
        Walk the register map and check every register can be read and written to correctly
        """
        rut: Reg
        {% for node in owned_elements.registers -%}
        # test access operations (read and/or write) to register:
        # {{'.'.join(node.get_path_segments())}}
        with self.subTest(msg='register: {{'.'.join(node.get_path_segments())}}'):
            rut=self.dut.{{'.'.join(get_python_path_segments(node))}} # type: ignore[union-attr,assignment]
            with patch(base_name + '.write_addr_space') as write_callback_mock, \
                patch(base_name + '.read_addr_space', return_value=1) as read_callback_mock:

                {% if node.has_sw_readable -%}
                {% if asyncoutput %}
                if not isinstance(rut, (RegAsyncReadOnly, RegAsyncReadWrite)):
                    raise TypeError('Register is not a Readable Async Type')
                {% else %}
                if not isinstance(rut, (RegReadOnly, RegReadWrite)):
                    raise TypeError('Register is not a Readable Type')
                {% endif %}
                # test reading back 1 (the unpatched version returns 0 so this confirms the patch works)
                self.assertEqual({% if asyncoutput %}await {%endif %}rut.read(), 1)
                read_callback_mock.assert_called_once_with(
                                    addr={{node.absolute_address}},
                                    width={{node.size * 8}},
                                    accesswidth=rut.accesswidth)

                # test the read check with high value
                read_callback_mock.reset_mock()
                read_callback_mock.return_value = {{get_reg_max_value_hex_string(node)}}
                self.assertEqual({% if asyncoutput %}await {%endif %}rut.read(), {{get_reg_max_value_hex_string(node)}})
                read_callback_mock.assert_called_once_with(
                                    addr={{node.absolute_address}},
                                    width={{node.size * 8}},
                                    accesswidth=rut.accesswidth)

                # test the read of the low value
                read_callback_mock.reset_mock()
                read_callback_mock.return_value = 0
                self.assertEqual({% if asyncoutput %}await {%endif %}rut.read(), 0x0)
                read_callback_mock.assert_called_once_with(
                                    addr={{node.absolute_address}},
                                    width={{node.size * 8}},
                                    accesswidth=rut.accesswidth)

                # test the read of a random value
                random_value = random.randrange(0, {{get_reg_max_value_hex_string(node)}}+1)
                read_callback_mock.reset_mock()
                read_callback_mock.return_value = random_value
                self.assertEqual({% if asyncoutput %}await {%endif %}rut.read(), random_value)
                read_callback_mock.assert_called_once_with(
                                    addr={{node.absolute_address}},
                                    width={{node.size * 8}},
                                    accesswidth=rut.accesswidth)

                # at the end of the read tests the write should not have been called
                read_callback_mock.reset_mock()
                write_callback_mock.assert_not_called()
                {% endif %}

                {% if node.has_sw_writable -%}
                {% if asyncoutput %}
                if not isinstance(rut, (RegAsyncWriteOnly, RegAsyncReadWrite)):
                    raise TypeError('Register is not a Writeable Async Type')
                {% else %}
                if not isinstance(rut, (RegWriteOnly, RegReadWrite)):
                    raise TypeError('Register is not a Writeable Type')
                {% endif %}
                # test the write with high value
                {% if asyncoutput %}await {%endif %}rut.write({{get_reg_max_value_hex_string(node)}})
                write_callback_mock.assert_called_once_with(
                                    addr={{node.absolute_address}},
                                    width={{node.size * 8}},
                                    accesswidth=rut.accesswidth,
                                    data={{get_reg_max_value_hex_string(node)}})
                write_callback_mock.reset_mock()

                # test the write of a low value
                {% if asyncoutput %}await {%endif %}rut.write(0)
                write_callback_mock.assert_called_once_with(
                                    addr={{node.absolute_address}},
                                    width={{node.size * 8}},
                                    accesswidth=rut.accesswidth,
                                    data=0)
                write_callback_mock.reset_mock()

                # test the write of a random
                random_value = random.randrange(0, {{get_reg_max_value_hex_string(node)}}+1)
                {% if asyncoutput %}await {%endif %}rut.write(random_value)  # type: ignore[union-attr]
                write_callback_mock.assert_called_once_with(
                                    addr={{node.absolute_address}},
                                    width={{node.size * 8}},
                                    accesswidth=rut.accesswidth,
                                    data=random_value)
                write_callback_mock.reset_mock()

                # test writing a value beyond the register range is blocked with an exception being raised
                with self.assertRaises(ValueError):
                    {% if asyncoutput %}await {%endif %}rut.write(-1)

                with self.assertRaises(ValueError):
                    {% if asyncoutput %}await {%endif %}rut.write({{get_reg_max_value_hex_string(node)}}+1)

                {%- else %}
                # test that a non-writable register has no write method and attempting one generates and error
                with self.assertRaises(AttributeError):
                    {% if asyncoutput %}await {%endif %}rut.write(0) # type: ignore[attr-defined]
                {%- endif %}

                # check the read has not been called in the write test
                read_callback_mock.assert_not_called()
        {% endfor %}

    {% if asyncoutput %}async {% endif %}def test_int_field_read_and_write(self) -> None:
        """
        Check the ability to read and write to integer (non-eumn) fields
        """
        fut:Field
        {% for node in owned_elements.fields -%}
        {%- if 'encode' not in node.list_properties() %}

        # test access operations (read and/or write) to field:
        # {{'.'.join(node.get_path_segments())}}
        with self.subTest(msg='field: {{'.'.join(node.get_path_segments())}}'):
            fut = self.dut.{{'.'.join(get_python_path_segments(node))}} # type: ignore[union-attr]
            with patch(base_name + '.write_addr_space') as write_callback_mock,\
                patch(base_name + '.read_addr_space', return_value=0) as read_callback_mock:

                {% if node.is_sw_readable %}
                {% if asyncoutput %}
                if not isinstance(fut, (FieldAsyncReadOnly, FieldAsyncReadWrite)):
                    raise TypeError('Test can not proceed as the fut is not a readable async field')
                {% else %}
                if not isinstance(fut, (FieldReadOnly, FieldReadWrite)):
                    raise TypeError('Test can not proceed as the fut is not a readable field')
                {% endif %}

                # read back - zero, this is achieved by setting the register to inverse bitmask
                read_callback_mock.return_value = {{get_field_inv_bitmask_hex_string(node)}}
                self.assertEqual({% if asyncoutput %}await {%endif %}fut.read(),
                                 0)
                read_callback_mock.assert_called_once_with(
                                    addr={{node.parent.absolute_address}},
                                    width={{node.parent.size * 8}},
                                    accesswidth=fut.parent_register.accesswidth)

                # read back - max_value, this is achieved by setting the register to bitmask
                read_callback_mock.reset_mock()
                read_callback_mock.return_value = {{get_field_bitmask_hex_string(node)}}
                self.assertEqual({% if asyncoutput %}await {%endif %}fut.read(),
                                 {{ get_field_max_value_hex_string(node) }})
                read_callback_mock.assert_called_once_with(
                                    addr={{node.parent.absolute_address}},
                                    width={{node.parent.size * 8}},
                                    accesswidth=fut.parent_register.accesswidth)

                # read back - random value
                read_callback_mock.reset_mock()
                random_value = random.randrange(0, {{get_reg_max_value_hex_string(node.parent)}}+1)
                read_callback_mock.return_value = random_value
                random_field_value = (random_value & {{get_field_bitmask_hex_string(node)}}) >> {{node.low}}
                {% if node.msb == node.high -%}
                self.assertEqual({% if asyncoutput %}await {%endif %}fut.read(),
                                 random_field_value)
                {% else -%}
                self.assertEqual({% if asyncoutput %}await {%endif %}fut.read(),
                                 self._reverse_bits(value=random_field_value, number_bits={{node.width}}))
                {% endif -%}
                read_callback_mock.assert_called_once_with(
                                    addr={{node.parent.absolute_address}},
                                    width={{node.parent.size * 8}},
                                    accesswidth=fut.parent_register.accesswidth)

                # at the end of the read tests the write should not have been called
                read_callback_mock.reset_mock()
                write_callback_mock.assert_not_called()
                {%- endif %}

                {%- if node.is_sw_writable %}
                # check the write
                {% if asyncoutput %}
                if not isinstance(fut, (FieldAsyncWriteOnly, FieldAsyncReadWrite)):
                    raise TypeError('Test can not proceed as the fut is not a writable async field')
                {% else %}
                if not isinstance(fut, (FieldWriteOnly, FieldReadWrite)):
                    raise TypeError('Test can not proceed as the fut is not a writable field')
                {% endif %}

                random_reg_value = random.randrange(0, {{get_reg_max_value_hex_string(node.parent)}} + 1)
                random_field_value = random.randrange(0, {{ get_field_max_value_hex_string(node) }} + 1)
                for reg_base_value in [0, {{get_reg_max_value_hex_string(node.parent)}}, random_reg_value]:
                    for field_value in [0, {{ get_field_max_value_hex_string(node) }}, random_field_value]:
                        read_callback_mock.reset_mock()
                        write_callback_mock.reset_mock()
                        read_callback_mock.return_value = reg_base_value

                        {% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.write(field_value) # type: ignore[union-attr]

                        {% if (((node.high+1) - node.low) < (node.parent.size*8)) and (node.parent.has_sw_readable) %}
                        read_callback_mock.assert_called_once_with(
                                    addr={{node.parent.absolute_address}},
                                    width={{node.parent.size * 8}},
                                    accesswidth=fut.parent_register.accesswidth)
                        {% else %}
                        read_callback_mock.assert_not_called()
                        {%- endif %}
                        {% if node.parent.has_sw_readable -%}
                        {% if node.msb == node.high -%}
                        write_callback_mock.assert_called_once_with(
                                    addr={{node.parent.absolute_address}},
                                    width={{node.parent.size * 8}},
                                    accesswidth=self.dut.{{'.'.join(get_python_path_segments(node))}}.parent_register.accesswidth, # type: ignore[union-attr]
                                    data=(reg_base_value & {{get_field_inv_bitmask_hex_string(node)}}) | \
                                         ({{get_field_bitmask_hex_string(node)}} & (field_value << {{node.low}})))
                        {% else -%}
                        write_callback_mock.assert_called_once_with(
                                    addr={{node.parent.absolute_address}},
                                    width={{node.parent.size * 8}},
                                    accesswidth=fut.parent_register.accesswidth,
                                    data=(reg_base_value & {{get_field_inv_bitmask_hex_string(node)}}) | \
                                         ({{get_field_bitmask_hex_string(node)}} & (self._reverse_bits(value=field_value, number_bits={{node.width}}) << {{node.low}})))
                        {% endif -%}
                        {% else -%}
                        # if the register is not readable, the value is simply written
                        {% if node.msb == node.high -%}
                        write_callback_mock.assert_called_once_with(
                                    addr={{node.parent.absolute_address}},
                                    width={{node.parent.size * 8}},
                                    accesswidth=fut.parent_register.accesswidth,
                                    data=field_value << {{node.low}})
                        {% else -%}
                        write_callback_mock.assert_called_once_with(
                                    addr={{node.parent.absolute_address}},
                                    width={{node.parent.size * 8}},
                                    accesswidth=fut.parent_register.accesswidth,
                                    data=self._reverse_bits(value=field_value, number_bits={{node.width}}) << {{node.low}})
                        {% endif -%}
                        {% endif %}

                # check invalid write values bounce
                with self.assertRaises(ValueError):
                    {% if asyncoutput %}await {%endif %}fut.write({{ get_field_max_value_hex_string(node) }} + 1)

                with self.assertRaises(ValueError):
                    {% if asyncoutput %}await {%endif %}fut.write(-1)
                {%- endif %}

        {%- endif %}
    {%- endfor %}

    {% if uses_enum %}
    {% if asyncoutput %}async {% endif %}def test_enum_field_read_and_write(self) -> None:
        """
        Check the ability to read and write to enum fields
        """
    {% for node in owned_elements.fields -%}
        {%- if 'encode' in node.list_properties() %}

        # test access operations (read and/or write) to field:
        # {{'.'.join(node.get_path_segments())}}
        with self.subTest(msg='field: {{'.'.join(node.get_path_segments())}}'):
            with patch(base_name + '.write_addr_space') as write_callback_mock,\
                patch(base_name + '.read_addr_space', return_value=0) as read_callback_mock:

                {% if node.is_sw_readable %}
                # read back test
                {%- for value_of_enum_needed in node.get_property('encode') -%}
                # set the simulated read_back value to {{value_of_enum_needed.name.upper()}}
                random_reg_value = random.randrange(0, {{get_reg_max_value_hex_string(node.parent)}} + 1)
                read_callback_mock.reset_mock()
                {% if node.msb == node.high -%}
                read_callback_mock.return_value = (random_reg_value & {{get_field_inv_bitmask_hex_string(node)}}) | \
                                                  ({{get_field_bitmask_hex_string(node)}} & ({{value_of_enum_needed.value}} << {{node.low}} ))
                {% else -%}
                read_callback_mock.return_value = (random_reg_value & {{get_field_inv_bitmask_hex_string(node)}}) | \
                                                  ({{get_field_bitmask_hex_string(node)}} & (self._reverse_bits(value={{value_of_enum_needed.value}}, number_bits={{node.width}}) << {{node.low}} ))
                {% endif -%}

                self.assertEqual({% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.read(), # type: ignore[union-attr]
                                 self.dut.{{'.'.join(get_python_path_segments(node))}}.enum_cls.{{value_of_enum_needed.name.upper()}} # type: ignore[attr-defined]
                                 )
                read_callback_mock.assert_called_once_with(
                                    addr={{node.parent.absolute_address}},
                                    width={{node.parent.size * 8}},
                                    accesswidth=self.dut.{{'.'.join(get_python_path_segments(node))}}.parent_register.accesswidth) # type: ignore[union-attr]
                {% endfor %}

                {% if node.get_property('encode').__len__() < (2**((node.high+1) - node.low)) %}
                # check that other values of the field int
                # that don't appear in the enum generate an
                # error
                for field_value in range(0, {{get_field_max_value_hex_string(node)}}+1):
                    if field_value in [{%- for value_of_enum_needed in node.get_property('encode') -%}{{value_of_enum_needed.value}}{% if not loop.last %}, {% endif %}{%- endfor %}]:
                        # legal int value of the eunm so no test is needed
                        continue
                    with self.assertRaises(ValueError):
                        read_callback_mock.reset_mock()
                        random_reg_value = random.randrange(0, {{get_reg_max_value_hex_string(node.parent)}} + 1)
                        {% if node.msb == node.high -%}
                        read_callback_mock.return_value = (random_reg_value & {{get_field_inv_bitmask_hex_string(node)}}) | \
                                         ({{get_field_bitmask_hex_string(node)}} & (field_value << {{node.low}}))
                        {% else -%}
                        read_callback_mock.return_value = (random_reg_value & {{get_field_inv_bitmask_hex_string(node)}}) | \
                                         ({{get_field_bitmask_hex_string(node)}} & (self._reverse_bits(value=field_value, number_bits={{node.width}}) << {{node.low}}))
                        {% endif -%}
                        _ = {% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.read() # type: ignore[union-attr]
                {% endif %}
                write_callback_mock.assert_not_called()
                {% endif %}

                {% if node.is_sw_writable %}
                enum_cls = self.dut.{{'.'.join(get_python_path_segments(node))}}.enum_cls
                {% for value_of_enum_needed in node.get_property('encode') %}
                random_reg_value = random.randrange(0, {{get_reg_max_value_hex_string(node.parent)}} + 1)
                read_callback_mock.reset_mock()
                write_callback_mock.reset_mock()
                read_callback_mock.return_value = random_reg_value

                {% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.write(enum_cls.{{value_of_enum_needed.name.upper()}}) # type: ignore[attr-defined]

                {% if ( node.width < (node.parent.size*8)) and (node.parent.has_sw_readable) %}
                read_callback_mock.assert_called_once()
                {% else %}
                read_callback_mock.assert_not_called()
                {%- endif %}

                {% if node.parent.has_sw_readable -%}
                {% if node.msb == node.high -%}
                write_callback_mock.assert_called_once_with(
                                    addr={{node.parent.absolute_address}},
                                    width={{node.parent.size * 8}},
                                    accesswidth=self.dut.{{'.'.join(get_python_path_segments(node))}}.parent_register.accesswidth, # type: ignore[union-attr]
                                    data=(random_reg_value & {{get_field_inv_bitmask_hex_string(node)}}) | \
                                         ({{get_field_bitmask_hex_string(node)}} & ({{value_of_enum_needed.value}} << {{node.low}})))
                {% else -%}
                write_callback_mock.assert_called_once_with(
                                    addr={{node.parent.absolute_address}},
                                    width={{node.parent.size * 8}},
                                    accesswidth=self.dut.{{'.'.join(get_python_path_segments(node))}}.parent_register.accesswidth, # type: ignore[union-attr]
                                    data=(random_reg_value & {{get_field_inv_bitmask_hex_string(node)}}) | \
                                         ({{get_field_bitmask_hex_string(node)}} & (self._reverse_bits(value={{value_of_enum_needed.value}}, number_bits={{node.width}}) << {{node.low}})))
                {% endif -%}
                {% else -%}
                # if the register is not readable, the value is simply written
                {% if node.msb == node.high -%}
                write_callback_mock.assert_called_once_with(
                                    addr={{node.parent.absolute_address}},
                                    width={{node.parent.size * 8}},
                                    accesswidth=self.dut.{{'.'.join(get_python_path_segments(node))}}.parent_register.accesswidth, # type: ignore[union-attr]
                                    data={{value_of_enum_needed.value}} << {{node.low}})
                {% else -%}
                write_callback_mock.assert_called_once_with(
                                    addr={{node.parent.absolute_address}},
                                    width={{node.parent.size * 8}},
                                    accesswidth=self.dut.{{'.'.join(get_python_path_segments(node))}}.parent_register.accesswidth, # type: ignore[union-attr]
                                    data=self._reverse_bits(value={{value_of_enum_needed.value}}, number_bits={{node.width}}) << {{node.low}})
                {% endif -%}
                {% endif %}

                {% endfor %}
                {% endif %}

        {%- endif %}
    {%- endfor %}
    {%- endif %}

    {% if asyncoutput %}async {% endif %}def test_register_read_fields(self) -> None:
        """
        Walk the register map and check every register read_fields method
        """
        reference_read_fields: dict[str, Union[bool, IntEnum, int]]
        {% for node in owned_elements.registers -%}
        {% if node.has_sw_readable %}
        with self.subTest(msg='register: {{'.'.join(node.get_path_segments())}}'):
            # test read_fields to register:
            # {{'.'.join(node.get_path_segments())}}
            # build up the register value with a random base value, overlaid with
            # a random value for each field
            rand_reg_value = random.randrange(0, {{get_reg_max_value_hex_string(node)}} + 1)
            {%- for child_node in node.children() %}
                {% if isinstance(child_node, systemrdlSignalNode) %}
            # do nothing with signal {{ child_node.inst_name }}
                {% elif isinstance(child_node, systemrdlFieldNode) %}
                    {% if child_node.is_sw_readable %}
                        {% if 'encode' in child_node.list_properties() %}
            rand_field_value = random.choice(list(self.dut.{{'.'.join(get_python_path_segments(child_node))}}.enum_cls)).value  # type: ignore[attr-defined]
                        {%- else %}
            rand_field_value = random.randrange(0, {{ get_field_max_value_hex_string(child_node) }} + 1)
                        {% endif %}
                        {% if child_node.msb == child_node.high %}
            rand_reg_value = (rand_reg_value & {{get_field_inv_bitmask_hex_string(child_node)}}) | (rand_field_value << {{ child_node.low }})
                        {% else %}
            rand_reg_value = (rand_reg_value & {{get_field_inv_bitmask_hex_string(child_node)}}) | (self._reverse_bits(value=rand_field_value, number_bits={{child_node.width}}) << {{ child_node.low }})
                         {% endif %}
                    {% endif %}
                {% else %}
            {{ raise_template_error('unexpected type') }}
                {% endif %}
            {% endfor %}
            with patch(base_name + '.write_addr_space') as write_callback_mock, \
                 patch(base_name + '.read_addr_space', return_value=rand_reg_value) as read_callback_mock:
                # the read_fields method gets a dictionary back
                # from the object with all the read back field
                # values
                reference_read_fields = { {% for child_node in node.children() -%}
                                            {% if isinstance(child_node, systemrdlFieldNode) %}
                                                {%- if child_node.is_sw_readable %}
                                                    {%- if not hide_node_func(child_node) %}
                                          '{{ child_node.inst_name }}' : {% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(child_node))}}.read(){%- if not loop.last -%}, {%- endif %} # type: ignore[union-attr]
                                                    {%- endif -%}
                                                {%- endif -%}
                                              {%- endif -%}
                                          {%- endfor %}
                                        }

                read_callback_mock.reset_mock()

                self.assertDictEqual({% if asyncoutput %}await {% endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.read_fields(), # type: ignore[union-attr]
                                     reference_read_fields)
                read_callback_mock.assert_called_once()
                write_callback_mock.assert_not_called()

        {%- endif %}
        {%- endfor %}

    {% if asyncoutput %}async {% endif %}def test_register_read_context_manager(self) -> None:
        """
        Walk the register map and check every register read_fields method
        """
        reference_read_fields: dict[str, Union[bool, IntEnum, int]]
        {% for node in owned_elements.registers -%}
        {% if node.has_sw_readable %}
        # test context manager to register:
        # {{'.'.join(node.get_path_segments())}}
        # build up the register value with a random base value, overlaid with
        # a random value for each field
        with self.subTest(msg='register: {{'.'.join(node.get_path_segments())}}'):
            rand_reg_value = random.randrange(0, {{get_reg_max_value_hex_string(node)}} + 1)
            {%- for field in node.children() %}
                {% if isinstance(field, systemrdlFieldNode) %}
                    {% if field.is_sw_readable %}
                        {% if 'encode' in field.list_properties() %}
            rand_field_value = random.choice(list(self.dut.{{'.'.join(get_python_path_segments(field))}}.enum_cls)).value   # type: ignore[attr-defined]
                        {% else %}
            rand_field_value = random.randrange(0, {{ get_field_max_value_hex_string(field) }} + 1)
                        {% endif %}
                        {% if field.msb == field.high %}
            rand_reg_value = (rand_reg_value & {{get_field_inv_bitmask_hex_string(field)}}) | (rand_field_value << {{ field.low }})
                        {% else %}
            rand_reg_value = (rand_reg_value & {{get_field_inv_bitmask_hex_string(field)}}) | (self._reverse_bits(value=rand_field_value, number_bits={{field.width}}) << {{ field.low }})
                        {% endif %}
                    {% endif %}
                {% else %}
                # skipping {{field.inst_name}}
                {% endif %}
            {% endfor %}
            with patch(base_name + '.write_addr_space') as write_callback_mock, \
                 patch(base_name + '.read_addr_space', return_value=rand_reg_value) as read_callback_mock:

                # first read the fields using the "normal" method, then compare the result to reading
                # via the context manager
                reference_read_fields = { {% for field in node.children() -%}
                                          {%- if isinstance(field, systemrdlFieldNode) -%}
                                          {%- if field.is_sw_readable %}
                                          {%- if not hide_node_func(field) %}
                                          '{{ field.inst_name }}' : {%if asyncoutput %}await {% endif %}self.dut.{{'.'.join(get_python_path_segments(field))}}.read(){%- if not loop.last -%}, {%- endif %}  # type: ignore[union-attr]
                                          {%- endif -%}
                                          {%- endif -%}
                                          {%- endif -%}
                                          {%- endfor %}
                                        }
                read_callback_mock.reset_mock()

                {% if node.has_sw_writable %}
                {% if asyncoutput %}async {% endif %}with self.dut.{{'.'.join(get_python_path_segments(node))}}.single_read_modify_write(skip_write=True) as reg_context: # type: ignore[union-attr]
                {% else %}
                {% if asyncoutput %}async {% endif %}with self.dut.{{'.'.join(get_python_path_segments(node))}}.single_read() as reg_context: # type: ignore[union-attr]
                {%- endif -%}
                    {% for field in node.children() -%}
                    {%- if isinstance(field, systemrdlFieldNode) -%}
                    {%- if field.is_sw_readable %}
                    {%- if not hide_node_func(field) %}
                    self.assertEqual(reference_read_fields['{{ field.inst_name }}'],
                                     {% if asyncoutput %} await {% endif %}reg_context.get_child_by_system_rdl_name('{{ field.inst_name }}').read()  # type: ignore[attr-defined,union-attr]
                                     )
                    {%- endif -%}
                    {%- endif -%}
                    {%- endif -%}
                    {%- endfor %}
                    pass

                read_callback_mock.assert_called_once()
                write_callback_mock.assert_not_called()

        {%- endif %}
        {%- endfor %}

    {% if asyncoutput %}async {% endif %}def test_register_write_context_manager(self) -> None:
        """
        Test the read modify write context manager
        """
        rut:Reg{% if asyncoutput %}Async{% endif %}ReadWrite
        {% if asyncoutput %}async {% endif %}def write_field_cominbinations(reg: Reg{% if asyncoutput %}Async{% endif %}ReadWrite, writable_fields:list[str]) -> None:
            with patch(base_name + '.write_addr_space') as write_callback_mock, \
                patch(base_name + '.read_addr_space', return_value=0) as read_callback_mock:
                for num_parm in range(1, len(writable_fields) + 1):
                    for fields_to_write in combinations(writable_fields, num_parm):
                        field_values = {}
                        expected_value = 0
                        for field_str in fields_to_write:
                            field = getattr(reg, field_str)
                            if hasattr(field, 'enum_cls'):
                                rand_enum_value = random.choice(list(field.enum_cls))
                                rand_field_value = rand_enum_value.value   # type: ignore[attr-defined]
                                field_values[field_str] = rand_enum_value
                            else:
                                rand_field_value = random.randrange(0, field.max_value + 1)
                                field_values[field_str] = rand_field_value

                            if field.msb == field.high:
                                expected_value = ( expected_value & field.inverse_bitmask ) | (rand_field_value << field.low)
                            elif field.msb == field.low:
                                expected_value = ( expected_value & field.inverse_bitmask ) | (self._reverse_bits(value=rand_field_value, number_bits=field.width) << field.low)
                            else:
                                raise RuntimeError('invalid msb/lsb high/low combination')

                        # read/write without verify
                        read_callback_mock.return_value = 0
                        {% if asyncoutput %}async {% endif %}with reg.single_read_modify_write(verify=False) as reg_session:
                            for field_name, field_value in field_values.items():
                                field = getattr(reg_session, field_name)
                                {% if asyncoutput %}await {% endif %}field.write(field_value)

                        write_callback_mock.assert_called_once_with(
                                addr=reg.address,
                                width=reg.width,
                                accesswidth=reg.accesswidth,
                                data=expected_value)
                        read_callback_mock.assert_called_once()
                        write_callback_mock.reset_mock()
                        read_callback_mock.reset_mock()

                        # read/write/verify pass
                        {% if asyncoutput %}async {% endif %}with reg.single_read_modify_write(verify=True) as reg_session:
                            for field_name, field_value in field_values.items():
                                field = getattr(reg_session, field_name)
                                {% if asyncoutput %}await {% endif %}field.write(field_value)
                            read_callback_mock.return_value = expected_value

                        write_callback_mock.assert_called_once_with(
                                addr=reg.address,
                                width=reg.width,
                                accesswidth=reg.accesswidth,
                                data=expected_value)
                        self.assertEqual(read_callback_mock.call_count, 2)
                        write_callback_mock.reset_mock()
                        read_callback_mock.reset_mock()

                        # read/write/verify pass
                        with self.assertRaises(RegisterWriteVerifyError) as context:
                            {% if asyncoutput %}async {% endif %}with reg.single_read_modify_write(verify=True) as reg_session:
                                for field_name, field_value in field_values.items():
                                    field = getattr(reg_session, field_name)
                                    {% if asyncoutput %}await {% endif %}field.write(field_value)
                                read_callback_mock.return_value = expected_value ^ reg_session.max_value

                        write_callback_mock.reset_mock()
                        read_callback_mock.reset_mock()

        {% for node in owned_elements.registers -%}
        {% if node.has_sw_writable and node.has_sw_readable %}
        with self.subTest(msg='register: {{'.'.join(node.get_path_segments())}}'):
            rut = self.dut.{{'.'.join(get_python_path_segments(node))}} # type: ignore[union-attr,assignment]
            if not isinstance(rut, Reg{% if asyncoutput %}Async{% endif %}ReadWrite):
                raise TypeError('Failed to find read/write register')
            {% if asyncoutput %}await {% endif %}write_field_cominbinations(reg=rut,
                               writable_fields = [ {% for field in get_reg_writable_fields(node, hide_node_func) -%}
                                                   '{{ safe_node_name(field) }}' {%- if not loop.last -%},{%- endif %}
                                                   {% endfor -%} ])
        {%- endif %}
        {%- endfor %}

    {% if asyncoutput %}async {% endif %}def test_register_write_fields(self) -> None:
        """
        Walk the register map and check every register write_fields method
        """
        rut:Reg{% if asyncoutput %}Async{% endif %}ReadWrite
        rand_enum_value:IntEnum
        {% if asyncoutput %}async {% endif %}def write_field_cominbinations(reg: Reg{% if asyncoutput %}Async{% endif %}ReadWrite, writable_fields:list[str]) -> None:
            with patch(base_name + '.write_addr_space') as write_callback_mock, \
                patch(base_name + '.read_addr_space', return_value=0) as read_callback_mock:
                for num_parm in range(1, len(writable_fields) + 1):
                    for fields_to_write in combinations(writable_fields, num_parm):
                        kwargs = {}
                        expected_value = 0
                        for field_str in fields_to_write:
                            field = getattr(reg, field_str)
                            if hasattr(field, 'enum_cls'):
                                rand_enum_value = random.choice(list(field.enum_cls))
                                rand_field_value = rand_enum_value.value   # type: ignore[attr-defined]
                                kwargs[field_str] = rand_enum_value
                            else:
                                rand_field_value = random.randrange(0, field.max_value + 1)
                                kwargs[field_str] = rand_field_value

                            if field.msb == field.high:
                                expected_value = ( expected_value & field.inverse_bitmask ) | (rand_field_value << field.low)
                            elif field.msb == field.low:
                                expected_value = ( expected_value & field.inverse_bitmask ) | (self._reverse_bits(value=rand_field_value, number_bits=field.width) << field.low)
                            else:
                                raise RuntimeError('invalid msb/lsb high/low combination')

                        {% if asyncoutput %}await {% endif %}reg.write_fields(**kwargs)
                        write_callback_mock.assert_called_once_with(
                                addr=reg.address,
                                width=reg.width,
                                accesswidth=reg.accesswidth,
                                data=expected_value)
                        read_callback_mock.assert_called_once()
                        write_callback_mock.reset_mock()
                        read_callback_mock.reset_mock()


        {% for node in owned_elements.registers -%}
        {% if node.has_sw_writable %}
        with self.subTest(msg='register: {{'.'.join(node.get_path_segments())}}'):
            # test read_fields to register:
            # {{'.'.join(node.get_path_segments())}}


            {% if node.has_sw_readable %}
            rut = self.dut.{{'.'.join(get_python_path_segments(node))}} # type: ignore[union-attr,assignment]
            if not isinstance(rut, Reg{% if asyncoutput %}Async{% endif %}ReadWrite):
                raise TypeError('Failed to find read/write register')
            {% if asyncoutput %}await {% endif %}write_field_cominbinations(reg=rut,
                                       writable_fields = [ {% for field in get_reg_writable_fields(node, hide_node_func) -%}
                                                           '{{ safe_node_name(field) }}' {%- if not loop.last -%},{%- endif %}
                                                           {% endfor -%} ])
            {% else %}
            kwargs = {} # type: ignore[var-annotated]
            expected_value = 0
            {% for field in get_reg_writable_fields(node, hide_node_func) %}
            {%- if 'encode' in field.list_properties() %}
            rand_enum_value = random.choice(list(self.dut.{{'.'.join(get_python_path_segments(field))}}.enum_cls))
            rand_field_value = rand_enum_value.value   # type: ignore[attr-defined]
            kwargs['{{field.inst_name}}'] = rand_enum_value
            {%- else %}
            rand_field_value = random.randrange(0, {{ get_field_max_value_hex_string(field) }} + 1)
            kwargs['{{field.inst_name}}'] = rand_field_value
            {%- endif  %}
            expected_value = ( expected_value & {{get_field_inv_bitmask_hex_string(field)}} ) | (rand_field_value << {{ field.low }})
            {% endfor %}
            with patch(base_name + '.write_addr_space') as write_callback_mock, \
                patch(base_name + '.read_addr_space', return_value=0) as read_callback_mock:
                {% if asyncoutput %}await {% endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.write_fields(**kwargs)  # type: ignore[union-attr]
                write_callback_mock.assert_called_once_with(
                                    addr={{node.absolute_address}},
                                    width={{node.size * 8}},
                                    accesswidth=self.dut.{{'.'.join(get_python_path_segments(node))}}.accesswidth, # type: ignore[union-attr]
                                    data=expected_value)
                read_callback_mock.assert_not_called()
                write_callback_mock.reset_mock()
                read_callback_mock.reset_mock()

            {% endif %}


        {%- endif %}
        {%- endfor %}

    {% if uses_memory %}
    {% if asyncoutput %}async {% endif %}def test_memory_read_and_write(self) -> None:
        """
        Walk the register map and check every register can be read and written to correctly
        """
        {% for node in owned_elements.memories -%}

        # test access operations (read and/or write) to register:
        # {{'.'.join(node.get_path_segments())}}
        with self.subTest(msg='memory: {{'.'.join(node.get_path_segments())}}'):
            with patch(base_name + '.write_addr_space') as write_callback_mock, \
                patch(base_name + '.read_addr_space', return_value=1) as read_callback_mock:

                {% if node.is_sw_readable -%}
                # checks single unit accesses at the first entry, the last entry and a random entry in
                # in each case check a 0, max value and random value being read
                for entry in [0, random.randint(0,{{node.get_property('mementries')-1}}), {{node.get_property('mementries')-1}}]:
                    for value in [0, random.randint(0,{{get_memory_max_entry_value_hex_string(node)}}), {{get_memory_max_entry_value_hex_string(node)}}]:
                        read_callback_mock.reset_mock()
                        read_callback_mock.return_value = value
                        {% if legacy_block_access %}
                        self.assertEqual({% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.read(start_entry=entry, number_entries=1), # type: ignore[union-attr]
                                                                 Array('{{get_array_typecode(node.get_property('memwidth'))}}', [value]))
                        {% else %}
                        self.assertEqual({% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.read(start_entry=entry, number_entries=1), # type: ignore[union-attr]
                                                                 [value])
                        {% endif %}

                        read_callback_mock.assert_called_once_with(
                                            addr={{node.absolute_address}}+(entry * {{get_memory_width_bytes(node)}}),
                                            width={{node.get_property('memwidth')}},
                                            accesswidth={{node.get_property('memwidth')}})

                # check a multi-entry read, if the memory is small do the entire memory, however, if
                # it is large limit the number of entries to 10
                entries_to_test = {% if node.get_property('mementries') > 10 %}10{% else %}{{node.get_property('mementries')}}{% endif %}
                {% if legacy_block_access %}
                random_data = Array('{{get_array_typecode(node.get_property('memwidth'))}}',
                                    [random.randint(0,{{get_memory_max_entry_value_hex_string(node)}}) for x in range(entries_to_test)])
                {% else %}
                random_data = [random.randint(0,{{get_memory_max_entry_value_hex_string(node)}}) for x in range(entries_to_test)]
                {% endif %}


                def read_data_mock(addr:int, width:int, accesswidth:int) -> int:
                    mem_entry = (addr - {{node.absolute_address}}) // {{get_memory_width_bytes(node)}}
                    return random_data[mem_entry]

                read_callback_mock.reset_mock()
                read_callback_mock.side_effect=read_data_mock

                self.assertEqual({% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.read(start_entry=0, number_entries=entries_to_test), # type: ignore[union-attr]
                                 random_data)

                write_callback_mock.assert_not_called()
                read_callback_mock.reset_mock()
                {% endif %}

                {% if node.is_sw_writable -%}
                # checks single unit accesses at the first entry, the last entry and a random entry in
                # in each case check a 0, max value and random value being read
                for entry in [0, random.randint(0,{{node.get_property('mementries')-1}}), {{node.get_property('mementries')-1}}]:
                    for value in [0, random.randint(0,{{get_memory_max_entry_value_hex_string(node)}}), {{get_memory_max_entry_value_hex_string(node)}}]:
                        write_callback_mock.reset_mock()
                        {% if legacy_block_access %}
                        {% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.write(start_entry=entry, data=Array('{{get_array_typecode(node.get_property('memwidth'))}}', [value])) # type: ignore[union-attr]
                        {% else %}
                        {% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.write(start_entry=entry, data=[value]) # type: ignore[union-attr]
                        {% endif %}
                        write_callback_mock.assert_called_once_with(
                                            addr={{node.absolute_address}}+(entry * {{get_memory_width_bytes(node)}}),
                                            width={{node.get_property('memwidth')}},
                                            accesswidth={{node.get_property('memwidth')}},
                                            data=value)

                read_callback_mock.assert_not_called()
                write_callback_mock.reset_mock()

                # check a multi-entry read, if the memory is small do the entire memory, however, if
                # it is large limit the number of entries to 10
                entries_to_test = {% if node.get_property('mementries') > 10 %}10{% else %}{{node.get_property('mementries')}}{% endif %}
                {% if legacy_block_access %}
                random_data = Array('{{get_array_typecode(node.get_property('memwidth'))}}',
                                    [random.randint(0,{{get_memory_max_entry_value_hex_string(node)}}) for x in range(entries_to_test)])
                {% else %}
                random_data = [random.randint(0,{{get_memory_max_entry_value_hex_string(node)}}) for x in range(entries_to_test)]
                {% endif %}
                {% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.write(start_entry=0, data=random_data) # type: ignore[union-attr]

                for x in range(entries_to_test):
                    self.assertEqual(write_callback_mock.call_args_list[x],
                                     call(addr={{node.absolute_address}} + (x * {{get_memory_width_bytes(node)}}),
                                          width={{node.get_property('memwidth')}},
                                          accesswidth={% if 'accesswidth' in node.list_properties() -%}{{node.get_property('accesswidth')}}{%- else -%}{{node.get_property('memwidth')}}{%- endif -%},
                                          data=random_data[x]))

                read_callback_mock.assert_not_called()
                write_callback_mock.reset_mock()

                {%- endif %}

        {%- endfor %}
    {%- endif %}

    def test_adding_attributes(self) -> None:
        """
        Walk the address map and attempt to set a new value on each node

        The attribute name: cppkbrgmgeloagvfgjjeiiushygirh was randomly generated to be unlikely to
        every be a attribute name

        """
        {% for node in owned_elements.nodes -%}
        with self.subTest(msg='node: {{'.'.join(node.get_path_segments())}}'):
            with self.assertRaises(AttributeError):
                # this line is trying to set an illegal value so by definition should fail the type
                # checks
                self.dut.{{'.'.join(get_python_path_segments(node))}}.cppkbrgmgeloagvfgjjeiiushygirh = 1 # type: ignore[attr-defined,union-attr]
        {% endfor %}

    {% if block == top_node %}
    def test_top_traversal_iterators(self) -> None:
        {% if asyncoutput %}
        expected_writable_regs: list[WritableAsyncRegister]
        expected_readable_regs: list[ReadableAsyncRegister]
        expected_memories:list[Union[MemoryAsyncReadOnly{% if legacy_block_access %}Legacy{% endif %}, MemoryAsyncWriteOnly{% if legacy_block_access %}Legacy{% endif %}, MemoryAsyncReadWrite{% if legacy_block_access %}Legacy{% endif %}]]

        {% else %}
        expected_writable_regs: list[WritableRegister]
        expected_readable_regs: list[ReadableRegister]
        expected_memories:list[Union[MemoryReadOnly{% if legacy_block_access %}Legacy{% endif %}, MemoryWriteOnly{% if legacy_block_access %}Legacy{% endif %}, MemoryReadWrite{% if legacy_block_access %}Legacy{% endif %}]]
        {% endif %}
        expected_sections : list[Union[{% if asyncoutput %}Async{% endif %}AddressMap, {% if asyncoutput %}Async{% endif %}RegFile]]

        # check the readable registers
        expected_readable_regs = [ {%- for child_node in top_node.children(unroll=True) %}
                                       {%- if not hide_node_func(child_node) %}
                                    {%- if isinstance(child_node, systemrdlRegNode) %}{% if child_node.has_sw_readable %}self.dut.{{'.'.join(get_python_path_segments(child_node))}}, # type: ignore[union-attr,list-item] {% endif %}{% endif %}
                                        {% endif %}
                                    {% endfor %} ]
        readable_regs = []
        for readable_reg in self.dut.get_readable_registers(unroll=True):  # type: ignore[union-attr]
            self.assertIsInstance(readable_reg, (Reg{% if asyncoutput %}Async{% endif %}ReadWrite, Reg{% if asyncoutput %}Async{% endif %}ReadOnly))
            readable_regs.append(readable_reg)
        self.assertCountEqual(expected_readable_regs, readable_regs)
        {# check the rolled case second #}
        expected_readable_regs = [ {%- for child_node in top_node.children(unroll=False) %}
                                       {%- if not hide_node_func(child_node) %}
                                   {%- if isinstance(child_node, systemrdlRegNode) %}{% if child_node.has_sw_readable %}self.dut.{{'.'.join(get_python_path_segments(child_node))}}, # type: ignore[union-attr,list-item] {% endif %}{% endif %}
                                       {% endif %}
                                   {% endfor %} ]
        readable_regs = []
        for readable_reg in self.dut.get_readable_registers(unroll=False):  # type: ignore[union-attr]
            readable_regs.append(readable_reg)
        self.assertCountEqual(expected_readable_regs, readable_regs)

        # check the writable registers
        expected_writable_regs = [ {%- for child_node in top_node.children(unroll=True) %}
                                       {%- if not hide_node_func(child_node) %}
                                   {%- if isinstance(child_node, systemrdlRegNode) %}{% if child_node.has_sw_writable %}self.dut.{{'.'.join(get_python_path_segments(child_node))}}, # type: ignore[union-attr,list-item] {% endif %}{% endif %}
                                       {% endif %}
                                   {% endfor %} ]
        writable_regs = []
        for writable_reg in self.dut.get_writable_registers(unroll=True):  # type: ignore[union-attr]
            self.assertIsInstance(writable_reg, (Reg{% if asyncoutput %}Async{% endif %}ReadWrite, Reg{% if asyncoutput %}Async{% endif %}WriteOnly))
            writable_regs.append(writable_reg)
        self.assertCountEqual(expected_writable_regs, writable_regs)
        {# check the rolled case second #}
        expected_writable_regs = [ {%- for child_node in top_node.children(unroll=False) %}
                                       {%- if not hide_node_func(child_node) %}
                                   {%- if isinstance(child_node, systemrdlRegNode) %}{% if child_node.has_sw_writable %}self.dut.{{'.'.join(get_python_path_segments(child_node))}}, # type: ignore[union-attr,list-item] {% endif %}{% endif %}
                                       {% endif %}
                                   {% endfor %} ]
        writable_regs = []
        for writable_reg in self.dut.get_writable_registers(unroll=False):  # type: ignore[union-attr]
            writable_regs.append(writable_reg)
        self.assertCountEqual(expected_writable_regs, writable_regs)

        # check the sections
        expected_sections = [ {%- for child_node in top_node.children(unroll=True) %}
                                  {%- if not hide_node_func(child_node) %}
                              {%- if isinstance(child_node, (systemrdlAddrmapNode, systemrdlRegfileNode)) %}self.dut.{{'.'.join(get_python_path_segments(child_node))}}, # type: ignore[union-attr,list-item] {% endif %}
                                  {% endif %}
                              {% endfor %} ]
        sections = []
        for section in self.dut.get_sections(unroll=True):  # type: ignore[union-attr]
            self.assertIsInstance(section, ({% if asyncoutput %}Async{% endif %}AddressMap, {% if asyncoutput %}Async{% endif %}RegFile))
            sections.append(section)
        self.assertCountEqual(expected_sections, sections)
        {# check the rolled case second #}
        expected_sections = [ {%- for child_node in top_node.children(unroll=False) %}
                                  {%- if not hide_node_func(child_node) %}
                              {%- if isinstance(child_node, (systemrdlAddrmapNode, systemrdlRegfileNode)) %}self.dut.{{'.'.join(get_python_path_segments(child_node))}},  # type: ignore[union-attr,list-item] {% endif %}
                                  {% endif %}
                              {% endfor %} ]
        sections = []
        for section in self.dut.get_sections(unroll=False):  # type: ignore[union-attr]
            sections.append(section)
        self.assertCountEqual(expected_sections, sections)

        # check the memories
        expected_memories = [ {%- for child_node in top_node.children(unroll=True) %}
                                  {%- if not hide_node_func(child_node) %}
                              {%- if isinstance(child_node, systemrdlMemNode) %}self.dut.{{'.'.join(get_python_path_segments(child_node))}}, # type: ignore[union-attr,list-item] {% endif %}
                                  {% endif %}
                              {% endfor %} ]
        memories = []
        for memory in self.dut.get_memories(unroll=True):  # type: ignore[union-attr]
            self.assertIsInstance(memory, (Memory{% if asyncoutput %}Async{% endif %}ReadOnly{% if legacy_block_access %}Legacy{% endif %}, Memory{% if asyncoutput %}Async{% endif %}WriteOnly{% if legacy_block_access %}Legacy{% endif %}, Memory{% if asyncoutput %}Async{% endif %}ReadWrite{% if legacy_block_access %}Legacy{% endif %}))
            memories.append(memory)
        self.assertCountEqual(expected_memories, memories)
        {# check the rolled case second #}
        expected_memories = [ {%- for child_node in top_node.children(unroll=False) %}
                                  {%- if not hide_node_func(child_node) %}
                              {%- if isinstance(child_node, systemrdlMemNode) %}self.dut.{{'.'.join(get_python_path_segments(child_node))}}, # type: ignore[union-attr,list-item] {% endif %}
                                  {% endif %}
                              {% endfor %} ]
        memories = []
        for memory in self.dut.get_memories(unroll=False):  # type: ignore[union-attr]
            self.assertIsInstance(memory, (Memory{% if asyncoutput %}Async{% endif %}ReadOnly{% if legacy_block_access %}Legacy{% endif %}, Memory{% if asyncoutput %}Async{% endif %}WriteOnly{% if legacy_block_access %}Legacy{% endif %}, Memory{% if asyncoutput %}Async{% endif %}ReadWrite{% if legacy_block_access %}Legacy{% endif %}, Memory{% if asyncoutput %}Async{% endif %}ReadOnlyArray, Memory{% if asyncoutput %}Async{% endif %}WriteOnlyArray, Memory{% if asyncoutput %}Async{% endif %}ReadWriteArray))
            memories.append(memory)
        self.assertCountEqual(expected_memories, memories)

    {% endif %}{# if block == top_block #}

    {% macro check_readable_register_iterators(node) %}
        {# check the unrolled case first #}
        expected_readable_regs = [ {%- for child_node in node.children(unroll=True) %}
                                       {%- if not hide_node_func(child_node) %}
                                    {%- if isinstance(child_node, systemrdlRegNode) %}{% if child_node.has_sw_readable %}self.dut.{{'.'.join(get_python_path_segments(child_node))}}, # type: ignore[union-attr,list-item] {% endif %}{% endif %}
                                        {% endif %}
                                    {% endfor %} ]
        readable_regs = []
        for readable_reg in self.dut.{{'.'.join(get_python_path_segments(node))}}.get_readable_registers(unroll=True):  # type: ignore[union-attr]
            self.assertIsInstance(readable_reg, (Reg{% if asyncoutput %}Async{% endif %}ReadWrite, Reg{% if asyncoutput %}Async{% endif %}ReadOnly))
            readable_regs.append(readable_reg)
        self.assertCountEqual(expected_readable_regs, readable_regs)
        {# check the rolled case second #}
        expected_readable_regs = [ {%- for child_node in node.children(unroll=False) %}
                                      {%- if not hide_node_func(child_node) %}
                                   {%- if isinstance(child_node, systemrdlRegNode) %}{% if child_node.has_sw_readable %}self.dut.{{'.'.join(get_python_path_segments(child_node))}}, # type: ignore[union-attr,list-item] {% endif %}{% endif %}
                                       {% endif %}
                                   {% endfor %} ]
        readable_regs = []
        for readable_reg in self.dut.{{'.'.join(get_python_path_segments(node))}}.get_readable_registers(unroll=False):  # type: ignore[union-attr]
            self.assertIsInstance(readable_reg, (Reg{% if asyncoutput %}Async{% endif %}ReadWrite, Reg{% if asyncoutput %}Async{% endif %}ReadOnly, Reg{% if asyncoutput %}Async{% endif %}ReadWriteArray, Reg{% if asyncoutput %}Async{% endif %}ReadOnlyArray))
            readable_regs.append(readable_reg)
        self.assertCountEqual(expected_readable_regs, readable_regs)
    {% endmacro %}

    {% macro check_writable_register_iterators(node) %}
        {# check the unrolled case first #}
        expected_writable_regs = [ {%- for child_node in node.children(unroll=True) %}
                                       {%- if not hide_node_func(child_node) %}
                                   {%- if isinstance(child_node, systemrdlRegNode) %}{% if child_node.has_sw_writable %}self.dut.{{'.'.join(get_python_path_segments(child_node))}}, # type: ignore[union-attr,list-item] {% endif %}{% endif %}
                                       {% endif %}
                                   {% endfor %} ]
        writable_regs = []
        for writable_reg in self.dut.{{'.'.join(get_python_path_segments(node))}}.get_writable_registers(unroll=True):  # type: ignore[union-attr]
            self.assertIsInstance(writable_reg, (Reg{% if asyncoutput %}Async{% endif %}ReadWrite, Reg{% if asyncoutput %}Async{% endif %}WriteOnly))
            writable_regs.append(writable_reg)
        self.assertCountEqual(expected_writable_regs, writable_regs)
        {# check the rolled case second #}
        expected_writable_regs = [ {%- for child_node in node.children(unroll=False) %}
                                      {%- if not hide_node_func(child_node) %}
                                   {%- if isinstance(child_node, systemrdlRegNode) %}{% if child_node.has_sw_writable %}self.dut.{{'.'.join(get_python_path_segments(child_node))}}, # type: ignore[union-attr,list-item] {% endif %}{% endif %}
                                       {% endif %}
                                   {% endfor %} ]
        writable_regs = []
        for writable_reg in self.dut.{{'.'.join(get_python_path_segments(node))}}.get_writable_registers(unroll=False):  # type: ignore[union-attr]
            self.assertIsInstance(writable_reg, (Reg{% if asyncoutput %}Async{% endif %}ReadWrite, Reg{% if asyncoutput %}Async{% endif %}WriteOnly, Reg{% if asyncoutput %}Async{% endif %}ReadWriteArray, Reg{% if asyncoutput %}Async{% endif %}WriteOnlyArray))
            writable_regs.append(writable_reg)
        self.assertCountEqual(expected_writable_regs, writable_regs)
    {% endmacro %}

    {% macro check_section_iterators(node) %}
        {# check the unrolled case first #}
        expected_sections = [ {%- for child_node in node.children(unroll=True) %}
                                  {%- if not hide_node_func(child_node) %}
                              {%- if isinstance(child_node, (systemrdlAddrmapNode, systemrdlRegfileNode)) %}self.dut.{{'.'.join(get_python_path_segments(child_node))}}, # type: ignore[union-attr,list-item] {% endif %}
                                  {% endif %}
                              {% endfor %} ]
        sections = []
        for section in self.dut.{{'.'.join(get_python_path_segments(node))}}.get_sections(unroll=True):  # type: ignore[union-attr]
            self.assertIsInstance(section, ({% if asyncoutput %}Async{% endif %}AddressMap, {% if asyncoutput %}Async{% endif %}RegFile))
            sections.append(section)
        self.assertCountEqual(expected_sections, sections)
        {# check the rolled case second #}
        expected_sections = [ {%- for child_node in node.children(unroll=False) %}
                                  {%- if not hide_node_func(child_node) %}
                              {%- if isinstance(child_node, (systemrdlAddrmapNode, systemrdlRegfileNode)) %}self.dut.{{'.'.join(get_python_path_segments(child_node))}},  # type: ignore[union-attr,list-item] {% endif %}
                                  {% endif %}
                              {% endfor %} ]
        sections = []
        for section in self.dut.{{'.'.join(get_python_path_segments(node))}}.get_sections(unroll=False):  # type: ignore[union-attr]
            self.assertIsInstance(section, ({% if asyncoutput %}Async{% endif %}AddressMap, {% if asyncoutput %}Async{% endif %}RegFile, {% if asyncoutput %}Async{% endif %}AddressMapArray, {% if asyncoutput %}Async{% endif %}RegFileArray))
            sections.append(section)
        self.assertCountEqual(expected_sections, sections)
    {% endmacro %}

    {% macro check_memory_iterators(node) %}
        {# check the unrolled case first #}
        expected_memories = [ {%- for child_node in node.children(unroll=True) %}
                                  {%- if not hide_node_func(child_node) %}
                              {%- if isinstance(child_node, systemrdlMemNode) %}self.dut.{{'.'.join(get_python_path_segments(child_node))}}, # type: ignore[union-attr,list-item] {% endif %}
                                  {% endif %}
                              {% endfor %} ]
        memories = []
        for memory in self.dut.{{'.'.join(get_python_path_segments(node))}}.get_memories(unroll=True):  # type: ignore[union-attr]
            self.assertIsInstance(memory, (Memory{% if asyncoutput %}Async{% endif %}ReadOnly{% if legacy_block_access %}Legacy{% endif %}, Memory{% if asyncoutput %}Async{% endif %}WriteOnly{% if legacy_block_access %}Legacy{% endif %}, Memory{% if asyncoutput %}Async{% endif %}ReadWrite{% if legacy_block_access %}Legacy{% endif %}))
            memories.append(memory)
        self.assertCountEqual(expected_memories, memories)
        {# check the rolled case second #}
        expected_memories = [ {%- for child_node in node.children(unroll=False) %}
                                  {%- if not hide_node_func(child_node) %}
                              {%- if isinstance(child_node, systemrdlMemNode) %}self.dut.{{'.'.join(get_python_path_segments(child_node))}}, # type: ignore[union-attr,list-item] {% endif %}
                                  {% endif %}
                              {% endfor %} ]
        memories = []
        for memory in self.dut.{{'.'.join(get_python_path_segments(node))}}.get_memories(unroll=False):  # type: ignore[union-attr]
            self.assertIsInstance(memory, (Memory{% if asyncoutput %}Async{% endif %}ReadOnly{% if legacy_block_access %}Legacy{% endif %}, Memory{% if asyncoutput %}Async{% endif %}WriteOnly{% if legacy_block_access %}Legacy{% endif %}, Memory{% if asyncoutput %}Async{% endif %}ReadWrite{% if legacy_block_access %}Legacy{% endif %}, Memory{% if asyncoutput %}Async{% endif %}ReadOnlyArray, Memory{% if asyncoutput %}Async{% endif %}WriteOnlyArray, Memory{% if asyncoutput %}Async{% endif %}ReadWriteArray))
            memories.append(memory)
        self.assertCountEqual(expected_memories, memories)
    {% endmacro %}

    def test_traversal_iterators(self) -> None:
        """
        Walk the address map and check that the iterators for each node as as expected
        """
        {% if asyncoutput %}
        expected_writable_fields: list[Union[FieldAsyncWriteOnly, FieldAsyncReadWrite]]
        expected_readable_fields: list[Union[FieldAsyncReadOnly, FieldAsyncReadWrite]]
        expected_fields: list[Union[FieldAsyncWriteOnly, FieldAsyncReadOnly, FieldAsyncReadWrite]]
        expected_writable_regs: list[WritableAsyncRegister]
        expected_readable_regs: list[ReadableAsyncRegister]
        expected_memories:list[Union[MemoryAsyncReadOnly{% if legacy_block_access %}Legacy{% endif %}, MemoryAsyncWriteOnly{% if legacy_block_access %}Legacy{% endif %}, MemoryAsyncReadWrite{% if legacy_block_access %}Legacy{% endif %}]]

        {% else %}
        expected_writable_fields: list[Union[FieldWriteOnly, FieldReadWrite]]
        expected_readable_fields: list[Union[FieldReadOnly, FieldReadWrite]]
        expected_fields: list[Union[FieldWriteOnly, FieldReadOnly, FieldReadWrite]]
        expected_writable_regs: list[WritableRegister]
        expected_readable_regs: list[ReadableRegister]
        expected_memories:list[Union[MemoryReadOnly{% if legacy_block_access %}Legacy{% endif %}, MemoryWriteOnly{% if legacy_block_access %}Legacy{% endif %}, MemoryReadWrite{% if legacy_block_access %}Legacy{% endif %}]]
        {% endif %}
        expected_sections : list[Union[{% if asyncoutput %}Async{% endif %}AddressMap, {% if asyncoutput %}Async{% endif %}RegFile]]

        # test all the registers
        {% for node in owned_elements.registers -%}
        with self.subTest(msg='register: {{'.'.join(node.get_path_segments())}}'):
                {# a register can only have fields beneath it #}
            expected_fields = [ {%- for child_node in node.children(unroll=True) -%}
                                    {% if isinstance(child_node, systemrdlFieldNode) %}
                                        {%- if not hide_node_func(child_node) -%}
                                    self.dut.{{'.'.join(get_python_path_segments(child_node))}}, # type: ignore[union-attr,list-item]
                                        {% endif %}
                                    {% endif %}
                                 {% endfor %}
                                         ]
            fields = []
            for field in self.dut.{{'.'.join(get_python_path_segments(node))}}.fields:  # type: ignore[union-attr]
                fields.append(field)
            self.assertCountEqual(expected_fields, fields)
                {% if node.has_sw_writable %}
            expected_writable_fields = [ {%- for child_node in node.children(unroll=True) -%}
                                            {%- if not hide_node_func(child_node) -%}
                                         {% if isinstance(child_node, systemrdlFieldNode) %}{% if child_node.is_sw_writable %}self.dut.{{'.'.join(get_python_path_segments(child_node))}}, # type: ignore[union-attr,list-item] {% endif %}{% endif %}
                                            {% endif %}
                                         {% endfor %}
                                         ]
            writable_fields = []
            for writable_field in self.dut.{{'.'.join(get_python_path_segments(node))}}.writable_fields:  # type: ignore[union-attr]
                writable_fields.append(writable_field)
            self.assertCountEqual(expected_writable_fields, writable_fields)
                    {% else %}
            # register should not have writable_fields attribute
            self.assertFalse(hasattr(self.dut.{{'.'.join(get_python_path_segments(node))}}, 'writable_fields')) # type: ignore[union-attr]
                    {% endif %}
                    {% if node.has_sw_readable %}
            expected_readable_fields = [ {%- for child_node in node.children(unroll=True) -%}
                                            {%- if not hide_node_func(child_node) -%}
                                         {% if isinstance(child_node, systemrdlFieldNode) %}{% if child_node.is_sw_readable %}self.dut.{{'.'.join(get_python_path_segments(child_node))}}, # type: ignore[union-attr,list-item] {% endif %}{% endif %}
                                            {% endif %}
                                         {% endfor %}
                                         ]
            readable_fields = []
            for readable_field in self.dut.{{'.'.join(get_python_path_segments(node))}}.readable_fields: # type: ignore[union-attr]
                readable_fields.append(readable_field)
            self.assertCountEqual(expected_readable_fields, readable_fields)
                    {% else %}
            # register should not have readable_fields attribute
            self.assertFalse(hasattr(self.dut.{{'.'.join(get_python_path_segments(node))}}, 'readable_fields')) # type: ignore[union-attr]
                    {% endif %}
        {% endfor %}
        # test all the memories
        {% for node in owned_elements.memories -%}

        with self.subTest(msg='memory: {{'.'.join(node.get_path_segments())}}'):
                    {% if node.is_sw_writable %}
                        {{ check_writable_register_iterators(node) | indent }}
                    {% else %}
            self.assertFalse(hasattr(self.dut.{{'.'.join(get_python_path_segments(node))}}, 'get_writeable_registers')) # type: ignore[union-attr]
                    {% endif %}
                    {% if node.is_sw_readable %}
                        {{ check_readable_register_iterators(node) | indent}}
                    {% else %}
            self.assertFalse(hasattr(self.dut.{{'.'.join(get_python_path_segments(node))}}, 'get_readable_registers')) # type: ignore[union-attr]
                    {% endif %}
        {% endfor %}
        # test all the address maps
        {% for node in owned_elements.addr_maps -%}
        with self.subTest(msg='addrmap: {{'.'.join(node.get_path_segments())}}'):
            {{ check_readable_register_iterators(node) | indent }}
            {{ check_writable_register_iterators(node) | indent}}
            {{ check_section_iterators(node) | indent }}
            {{ check_memory_iterators(node) | indent}}
        {% endfor %}
        # test all the register files
        {% for node in owned_elements.reg_files -%}
        with self.subTest(msg='regfile: {{'.'.join(node.get_path_segments())}}'):
            {{ check_readable_register_iterators(node) | indent }}
            {{ check_writable_register_iterators(node)  | indent}}
            {{ check_section_iterators(node) | indent }}
            self.assertFalse(hasattr(self.dut.{{'.'.join(get_python_path_segments(node))}}, 'get_memories')) # type: ignore[union-attr]
        {% endfor %}

    def test_name_map(self) -> None:
        """
        Check that the function for getting a node by its original systemRDL name works
        """
        {% for node in owned_elements.nodes -%}
        {% for child_node in node.children(unroll=False) %}
        {% if not isinstance(child_node, systemrdlSignalNode) %}
        {%- if not hide_node_func(child_node) %}
        self.assertEqual(self.dut.{{'.'.join(get_python_path_segments(node))}}.get_child_by_system_rdl_name('{{child_node.inst_name}}').inst_name, '{{child_node.inst_name}}')  # type: ignore[union-attr]
        {% endif %}
        {% endif %}
        {% endfor %}
        {% endfor %}

    {% if owned_elements.has_hidden_nodes %}
    def test_hidden(self) -> None:
        """
        Check that any 1st layer hidden node is not present
        """
        {% for node in owned_elements.hidden_nodes -%}
        with self.subTest(msg='hidden_node: {{'.'.join(node.get_path_segments())}}'):
            {% if node.parent ==  top_node %}
            with self.assertRaises(KeyError):
                self.dut.get_child_by_system_rdl_name('{{node.inst_name}}')
            {% else %}
            with self.assertRaises(KeyError):
                self.dut.{{'.'.join(get_python_path_segments(node.parent))}}.get_child_by_system_rdl_name('{{node.inst_name}}')
            {% endif %}
            with self.assertRaises(AttributeError):
                _ = self.dut.{{'.'.join(get_python_path_segments(node))}} # type: ignore[attr-defined]
        {% endfor %}
    {% endif %}



class {{fq_block_name}}_block_access({{top_node.inst_name}}_TestCase_BlockAccess): # type: ignore[valid-type,misc]
    """
    tests for all the block access methods
    """

    {% if uses_memory %}
    {% if asyncoutput %}async {% endif %}def test_memory_read_and_write(self) -> None:
        """
        Walk the register map and check every register can be read and written to correctly
        """
        {% for node in owned_elements.memories -%}

        # test access operations (read and/or write) to register:
        # {{'.'.join(node.get_path_segments())}}
        with patch(base_name + '.write_addr_space') as write_callback_mock,\
                            patch(base_name + '.read_addr_space', return_value=1) as read_callback_mock, \
                            patch(base_name + '.read_block_addr_space',
                                  return_value={% if legacy_block_access %}Array('{{get_array_typecode(node.get_property('memwidth'))}}', [0]){% else %}[0]{% endif %}) as read_block_callback_mock , \
                            patch(base_name + '.write_block_addr_space') as write_block_callback_mock:

            {% if node.is_sw_readable -%}
            # checks single unit accesses at the first entry, the last entry and a random entry in
            # in each case check a 0, max value and random value being read
            for entry in [0, random.randint(0,{{node.get_property('mementries')-1}}), {{node.get_property('mementries')-1}}]:
                for value in [0, random.randint(0,{{get_memory_max_entry_value_hex_string(node)}}), {{get_memory_max_entry_value_hex_string(node)}}]:
                    read_block_callback_mock.reset_mock()
                    {% if legacy_block_access %}
                    read_block_callback_mock.return_value = Array('{{get_array_typecode(node.get_property('memwidth'))}}',
                                                                  [value])
                    {% else %}
                    read_block_callback_mock.return_value = [value]
                    {% endif %}

                    {% if legacy_block_access %}
                    self.assertEqual({% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.read(start_entry=entry, number_entries=1), # type: ignore[union-attr]
                                                             Array('{{get_array_typecode(node.get_property('memwidth'))}}', [value]))
                    {% else %}
                    self.assertEqual({% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.read(start_entry=entry, number_entries=1), # type: ignore[union-attr]
                                                             [value])
                    {% endif %}
                    read_block_callback_mock.assert_called_once_with(
                                        addr={{node.absolute_address}}+(entry * {{get_memory_width_bytes(node)}}),
                                        width={{node.get_property('memwidth')}},
                                        accesswidth={{node.get_property('memwidth')}},
                                        length=1)

            # check a multi-entry read, if the memory is small do the entire memory, however, if
            # it is large limit the number of entries to 10
            entries_to_test = {% if node.get_property('mementries') > 10 %}10{% else %}{{node.get_property('mementries')}}{% endif %}
            {% if legacy_block_access %}
            random_data = Array('{{get_array_typecode(node.get_property('memwidth'))}}',
                                [random.randint(0,{{get_memory_max_entry_value_hex_string(node)}}) for x in range(entries_to_test)])
            {% else %}
            random_data = [random.randint(0,{{get_memory_max_entry_value_hex_string(node)}}) for x in range(entries_to_test)]
            {% endif %}


            read_block_callback_mock.reset_mock()
            read_block_callback_mock.return_value = random_data

            self.assertEqual({% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.read(start_entry=0, # type: ignore[union-attr]
                                          number_entries=entries_to_test),
                                          random_data)

            write_callback_mock.assert_not_called()
            read_callback_mock.assert_not_called()
            write_block_callback_mock.assert_not_called()
            read_block_callback_mock.reset_mock()
            {% endif %}

            {% if node.is_sw_writable -%}
            # checks single unit accesses at the first entry, the last entry and a random entry in
            # in each case check a 0, max value and random value being read
            for entry in [0, random.randint(0,{{node.get_property('mementries')-1}}), {{node.get_property('mementries')-1}}]:
                for value in [0, random.randint(0,{{get_memory_max_entry_value_hex_string(node)}}), {{get_memory_max_entry_value_hex_string(node)}}]:
                    write_block_callback_mock.reset_mock()
                    {% if legacy_block_access %}
                    {% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.write(start_entry=entry, data=Array('{{get_array_typecode(node.get_property('memwidth'))}}', [value])) # type: ignore[union-attr]
                    write_block_callback_mock.assert_called_once_with(
                                        addr={{node.absolute_address}}+(entry * {{get_memory_width_bytes(node)}}),
                                        width={{node.get_property('memwidth')}},
                                        accesswidth={{node.get_property('memwidth')}},
                                        data=Array('{{get_array_typecode(node.get_property('memwidth'))}}', [value]))
                    {% else %}
                    {% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.write(start_entry=entry, data=[value]) # type: ignore[union-attr]
                    write_block_callback_mock.assert_called_once_with(
                                        addr={{node.absolute_address}}+(entry * {{get_memory_width_bytes(node)}}),
                                        width={{node.get_property('memwidth')}},
                                        accesswidth={{node.get_property('memwidth')}},
                                        data=[value])
                    {% endif %}


            read_callback_mock.assert_not_called()
            write_callback_mock.assert_not_called()
            read_block_callback_mock.assert_not_called()
            write_block_callback_mock.reset_mock()

            # check a multi-entry read, if the memory is small do the entire memory, however, if
            # it is large limit the number of entries to 10
            entries_to_test = {% if node.get_property('mementries') > 10 %}10{% else %}{{node.get_property('mementries')}}{% endif %}
            {% if legacy_block_access %}
            random_data = Array('{{get_array_typecode(node.get_property('memwidth'))}}',
                                [random.randint(0,{{get_memory_max_entry_value_hex_string(node)}}) for x in range(entries_to_test)])
            {% else %}
            random_data = [random.randint(0,{{get_memory_max_entry_value_hex_string(node)}}) for x in range(entries_to_test)]
            {% endif %}
            {% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.write(start_entry=0, data=random_data) # type: ignore[union-attr]

            write_block_callback_mock.assert_called_once_with(
                                        addr={{node.absolute_address}},
                                        width={{node.get_property('memwidth')}},
                                        accesswidth={{node.get_property('memwidth')}},
                                        data=random_data)

            read_callback_mock.assert_not_called()
            write_callback_mock.assert_not_called()
            read_block_callback_mock.assert_not_called()
            write_block_callback_mock.reset_mock()

            {%- endif %}

        {%- endfor %}
    {%- endif %}

    {% if asyncoutput %}async {% endif %}def test_register_array_context_manager(self) -> None:
        """
        Walk the register map and check that register map context managers work correctly
        """
        {% for node in rolled_owned_reg_array %}
        # test context manager to register:
        # {{'.'.join(node.get_path_segments())}}
        # size {{node.size}}
        # total_size {{node.total_size}}
        empty_read = [0 for i in range({{node.total_size}} // {{node.size}})]
        follow_along = [0 for i in range({{node.total_size}} // {{node.size}})]
        with self.subTest(msg='register: {{'.'.join(node.get_path_segments())}}'):
            with patch(base_name + '.write_addr_space') as write_callback_mock,\
                                patch(base_name + '.read_addr_space', return_value=0) as read_callback_mock, \
                                patch(base_name + '.read_block_addr_space',
                                      return_value={% if legacy_block_access %}Array('{{get_array_typecode(node.size * 8)}}', empty_read){% else %}empty_read{% endif %}) as read_block_callback_mock , \
                                patch(base_name + '.write_block_addr_space') as write_block_callback_mock:
                {% if node.has_sw_readable and node.has_sw_writable -%}
                {% if asyncoutput %}async {% endif %}with self.dut.{{'.'.join(get_python_path_segments(node))}}.single_read_modify_write() as dut:
                    pass
                {% elif not node.has_sw_readable and node.has_sw_writable-%}
                {% if asyncoutput %}async {% endif %}with self.dut.{{'.'.join(get_python_path_segments(node))}}.single_write() as dut:
                    pass
                read_block_callback_mock.assert_not_called()
                {% elif node.has_sw_readable and not node.has_sw_writable-%}
                {% if asyncoutput %}async {% endif %}with self.dut.{{'.'.join(get_python_path_segments(node))}}.single_read() as dut:
                    pass
                write_block_callback_mock.assert_not_called()
                {% endif %}
                read_callback_mock.assert_not_called()
                write_callback_mock.assert_not_called()

        {%- endfor %}

class {{fq_block_name}}_alt_block_access({{top_node.inst_name}}_TestCase_AltBlockAccess): # type: ignore[valid-type,misc]
    """
    tests for all the block access methods with the alternative callbacks, this is a simpler
    version of the tests above
    """
    {% if uses_memory %}
    {% if asyncoutput %}async {% endif %}def test_memory_read_and_write(self) -> None:
        """
        Walk the register map and check every register can be read and written to correctly
        """
        {% for node in owned_elements.memories -%}

        # test access operations (read and/or write) to register:
        # {{'.'.join(node.get_path_segments())}}
        entries_to_test = {% if node.get_property('mementries') > 10 %}10{% else %}{{node.get_property('mementries')}}{% endif %}
        {% if node.get_property('memwidth') not in [8, 16, 32, 64] and not legacy_block_access %}
            {% if node.is_sw_readable %}
        with self.assertRaises(UnsupportedWidthError):
            _ = {% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.read(start_entry=0, # type: ignore[union-attr]
                                      number_entries=entries_to_test)
            {% endif %}
        {% else %}
        with patch(base_name + '.write_addr_space') as write_callback_mock,\
                            patch(base_name + '.read_addr_space', return_value=1) as read_callback_mock, \
                            patch(base_name + '.read_block_addr_space_alt',
                                  return_value={% if not legacy_block_access %}Array('{{get_array_typecode(node.get_property('memwidth'))}}', [0]){% else %}[0]{% endif %}) as read_block_callback_mock , \
                            patch(base_name + '.write_block_addr_space_alt') as write_block_callback_mock:

            {% if node.is_sw_readable -%}
            random_data_list = [random.randint(0,{{get_memory_max_entry_value_hex_string(node)}}) for x in range(entries_to_test)]
            random_data_array = Array('{{get_array_typecode(node.get_property('memwidth'))}}', random_data_list)

            read_block_callback_mock.reset_mock()
            {% if not legacy_block_access %}
            read_block_callback_mock.return_value = random_data_array
            self.assertEqual({% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.read(start_entry=0, # type: ignore[union-attr]
                                          number_entries=entries_to_test),
                                          random_data_list)
            {% else %}
            read_block_callback_mock.return_value = random_data_list
            self.assertEqual({% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.read(start_entry=0, # type: ignore[union-attr]
                                          number_entries=entries_to_test),
                                          random_data_array)
            {% endif %}

            write_callback_mock.assert_not_called()
            read_callback_mock.assert_not_called()
            write_block_callback_mock.assert_not_called()
            read_block_callback_mock.reset_mock()
            {% endif %}

            {% if node.is_sw_writable -%}
            # check a multi-entry read, if the memory is small do the entire memory, however, if
            # it is large limit the number of entries to 10
            entries_to_test = {% if node.get_property('mementries') > 10 %}10{% else %}{{node.get_property('mementries')}}{% endif %}
            random_data_list = [random.randint(0,{{get_memory_max_entry_value_hex_string(node)}}) for x in range(entries_to_test)]
            random_data_array = Array('{{get_array_typecode(node.get_property('memwidth'))}}', random_data_list)
            {% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.write(start_entry=0, data={% if legacy_block_access %}random_data_array{% else %}random_data_list{% endif %}) # type: ignore[union-attr]

            write_block_callback_mock.assert_called_once_with(
                                        addr={{node.absolute_address}},
                                        width={{node.get_property('memwidth')}},
                                        accesswidth={{node.get_property('memwidth')}},
                                        data={% if not legacy_block_access %}random_data_array{% else %}random_data_list{% endif %})

            read_callback_mock.assert_not_called()
            write_callback_mock.assert_not_called()
            read_block_callback_mock.assert_not_called()
            write_block_callback_mock.reset_mock()

            {%- endif %}
        {% endif %}
        {%- endfor %}
    {%- endif %}

    {% if asyncoutput %}async {% endif %}def test_register_array_context_manager(self) -> None:
        """
        Walk the register map and check that register map context managers work correctly
        """
        {% for node in rolled_owned_reg_array %}
        # test context manager to register with alt block interfaces:
        # {{'.'.join(node.get_path_segments())}}
        # size {{node.size}}
        # total_size {{node.total_size}}
        {% if node.size > 8 and not legacy_block_access %}
        with self.assertRaises(UnsupportedWidthError):
            {% if node.has_sw_readable and node.has_sw_writable -%}
            {% if asyncoutput %}async {% endif %}with self.dut.{{'.'.join(get_python_path_segments(node))}}.single_read_modify_write() as dut:
                pass
            {% elif not node.has_sw_readable and node.has_sw_writable-%}
            {% if asyncoutput %}async {% endif %}with self.dut.{{'.'.join(get_python_path_segments(node))}}.single_write() as dut:
                pass
            read_block_callback_mock.assert_not_called()
            {% elif node.has_sw_readable and not node.has_sw_writable-%}
            {% if asyncoutput %}async {% endif %}with self.dut.{{'.'.join(get_python_path_segments(node))}}.single_read() as dut:
                pass
            write_block_callback_mock.assert_not_called()
            {% endif %}
        {% else %}
        empty_read = [0 for i in range({{node.total_size}} // {{node.size}})]
        follow_along = [0 for i in range({{node.total_size}} // {{node.size}})]
        with self.subTest(msg='register: {{'.'.join(node.get_path_segments())}}'):
            with patch(base_name + '.write_addr_space') as write_callback_mock,\
                            patch(base_name + '.read_addr_space', return_value=1) as read_callback_mock, \
                            patch(base_name + '.read_block_addr_space_alt',
                                  return_value={% if not legacy_block_access %}Array('{{get_array_typecode(node.size * 8)}}', empty_read){% else %}empty_read{% endif %}) as read_block_callback_mock , \
                            patch(base_name + '.write_block_addr_space_alt') as write_block_callback_mock:
                {% if node.has_sw_readable and node.has_sw_writable -%}
                {% if asyncoutput %}async {% endif %}with self.dut.{{'.'.join(get_python_path_segments(node))}}.single_read_modify_write() as dut:
                    pass
                {% elif not node.has_sw_readable and node.has_sw_writable-%}
                {% if asyncoutput %}async {% endif %}with self.dut.{{'.'.join(get_python_path_segments(node))}}.single_write() as dut:
                    pass
                read_block_callback_mock.assert_not_called()
                {% elif node.has_sw_readable and not node.has_sw_writable-%}
                {% if asyncoutput %}async {% endif %}with self.dut.{{'.'.join(get_python_path_segments(node))}}.single_read() as dut:
                    pass
                write_block_callback_mock.assert_not_called()
                {% endif %}
                read_callback_mock.assert_not_called()
                write_callback_mock.assert_not_called()
        {% endif %}
        {%- endfor %}


if __name__ == '__main__':
{% if asyncoutput %}
    if sys.version_info < (3, 8):
        asynctest.main()
    else:
        unittest.main()
{% else %}
    unittest.main()
{% endif %}





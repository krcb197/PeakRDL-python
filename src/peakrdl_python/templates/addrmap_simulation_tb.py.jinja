{#
peakrdl-python is a tool to generate Python Register Access Layer (RAL) from SystemRDL
Copyright (C) 2021 - 2025

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation, either version 3 of
the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
#}

{% include "header_tb.py.jinja" with context %}

{% from 'template_ultilities.py.jinja' import peakrdl_python_sim_lib with context %}
{% from 'template_ultilities.py.jinja' import peakrdl_python_lib with context %}
{% from 'template_ultilities.py.jinja' import peakrdl_python_lib_test with context %}
{# the following defining the number relative steps up to the lib and sim_lib packages from the current file #}
{% set lib_depth = 1 %}

{% if legacy_block_access %}from array import array as Array{% endif %}
from typing import Union, cast
{% if asyncoutput %}
import asyncio
import unittest
from unittest.mock import Mock
{% else %}
import unittest
from unittest.mock import Mock
{% endif %}
import random
{% if legacy_enum_type %}
from enum import IntEnum
{% endif %}

from {{ peakrdl_python_sim_lib(depth=lib_depth) }}.register import Register,MemoryRegister
from {{ peakrdl_python_sim_lib(depth=lib_depth) }}.field import Field

from ._{{top_node.inst_name}}_sim_test_base import {{top_node.inst_name}}_SimTestCase_BlockAccess
from ._{{top_node.inst_name}}_sim_test_base import __name__ as base_name
from ._{{top_node.inst_name}}_test_base import random_enum_reg_value

{% if not legacy_enum_type %}
from {{ peakrdl_python_lib(depth=lib_depth) }} import SystemRDLEnum
{% endif %}

from {{ peakrdl_python_lib_test(depth=lib_depth) }} import reverse_bits

class {{fq_block_name}}_block_access({{top_node.inst_name}}_SimTestCase_BlockAccess): # type: ignore[valid-type,misc]
    """
    tests for all the block access methods
    """

    {% if uses_memory %}
    {% if asyncoutput %}async {% endif %}def test_memory_read_and_write(self) -> None:
        """
        Walk the register map and check every register can be read and written to correctly
        """
        {% for node in owned_elements.memories -%}

        # test access operations (read and/or write) to register:
        # {{'.'.join(node.get_path_segments())}}

        {% if node.is_sw_readable -%}
        # checks single unit accesses at the first entry, the last entry and a random entry in
        # in each case check a 0, max value and random value being read
        for entry in [0, random.randint(0,{{node.get_property('mementries')-1}}), {{node.get_property('mementries')-1}}]:

            self.assertEqual({% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.read(start_entry=entry, number_entries=1), # type: ignore[union-attr]
                                                     {% if legacy_block_access %}Array('{{get_array_typecode(node.get_property('memwidth'))}}', [0]){% else %}[0]{% endif %})

        # check a multi-entry read, if the memory is small do the entire memory, however, if
        # it is large limit the number of entries to 10
        entries_to_test = {% if node.get_property('mementries') > 10 %}10{% else %}{{node.get_property('mementries')}}{% endif %}
        {% if legacy_block_access %}
        self.assertEqual({% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.read(start_entry=0, # type: ignore[union-attr]
                                      number_entries=entries_to_test),
                                      Array('{{get_array_typecode(node.get_property('memwidth'))}}', [0 for _ in range(entries_to_test)]))
        {% else %}
        self.assertEqual({% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.read(start_entry=0, # type: ignore[union-attr]
                                      number_entries=entries_to_test),
                                      [0 for _ in range(entries_to_test)])
        {% endif %}
        {% endif %}

        {% if node.is_sw_writable -%}
        # checks single unit accesses at the first entry, the last entry and a random entry in
        # in each case check a 0, max value and random value being read
        for entry in [0, random.randint(0,{{node.get_property('mementries')-1}}), {{node.get_property('mementries')-1}}]:
            for value in [0, random.randint(0,{{get_memory_max_entry_value_hex_string(node)}}), {{get_memory_max_entry_value_hex_string(node)}}]:
                {% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.write(start_entry=entry, data={% if legacy_block_access %}Array('{{get_array_typecode(node.get_property('memwidth'))}}', [value]){% else %}[value]{% endif %}) # type: ignore[union-attr]
                {% if node.is_sw_readable -%}
                self.assertEqual({% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.read(start_entry=entry, number_entries=1), # type: ignore[union-attr]
                                 {% if legacy_block_access %}Array('{{get_array_typecode(node.get_property('memwidth'))}}', [value]){% else %}[value]{% endif %})
                {% endif %}

        # check a multi-entry read, if the memory is small do the entire memory, however, if
        # it is large limit the number of entries to 10
        entries_to_test = {% if node.get_property('mementries') > 10 %}10{% else %}{{node.get_property('mementries')}}{% endif %}
        {% if legacy_block_access %}
        random_data = Array('{{get_array_typecode(node.get_property('memwidth'))}}',
                            [random.randint(0,{{get_memory_max_entry_value_hex_string(node)}}) for x in range(entries_to_test)])
        {% else %}
        random_data = [random.randint(0,{{get_memory_max_entry_value_hex_string(node)}}) for x in range(entries_to_test)]
        {% endif %}
        {% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.write(start_entry=0, data=random_data) # type: ignore[union-attr]
        {% if node.is_sw_readable -%}
        self.assertEqual({% if asyncoutput %}await {%endif %}self.dut.{{'.'.join(get_python_path_segments(node))}}.read(start_entry=0, number_entries=entries_to_test), # type: ignore[union-attr]
                         random_data)
        {% endif %}

        {%- endif %}

        {%- endfor %}
    {%- endif %}

if __name__ == '__main__':

    unittest.main()






{#
peakrdl-python is a tool to generate Python Register Access Layer (RAL) from SystemRDL
Copyright (C) 2021 - 2023

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
#}

{% include "header.py.jinja" with context %}

from typing import Iterator
from typing import Optional
from typing import Union
from typing import Type
from typing import overload
from typing import Literal
from typing import Any
from typing import NoReturn
import warnings
{% if legacy_block_access %}from array import array as Array{% endif %}


from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import Node, NodeArray, Base
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import UDPStruct

from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib  import AddressMapArray, RegFileArray
{% if asyncoutput -%}
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import AsyncMemory, AsyncMemoryArray
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import AsyncAddressMap
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import AsyncRegFile
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib  import AsyncAddressMapArray
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib  import AsyncRegFileArray
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import MemoryAsyncReadOnly{% if legacy_block_access %}Legacy{% endif %}, MemoryAsyncWriteOnly{% if legacy_block_access %}Legacy{% endif %}, MemoryAsyncReadWrite{% if legacy_block_access %}Legacy{% endif %}
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import MemoryAsyncReadOnlyArray, MemoryAsyncWriteOnlyArray, MemoryAsyncReadWriteArray
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import AsyncReg, AsyncRegArray
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import RegAsyncReadOnly, RegAsyncWriteOnly, RegAsyncReadWrite
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import RegAsyncReadOnlyArray, RegAsyncWriteOnlyArray, RegAsyncReadWriteArray
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import FieldAsyncReadOnly, FieldAsyncWriteOnly, FieldAsyncReadWrite, Field
{% if uses_enum %}from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import FieldEnumAsyncReadOnly, FieldEnumAsyncWriteOnly, FieldEnumAsyncReadWrite{% endif %}
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import ReadableAsyncRegister, WritableAsyncRegister
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import ReadableAsyncMemory{% if legacy_block_access %}Legacy{% endif %}, WritableAsyncMemory{% if legacy_block_access %}Legacy{% endif %}
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import ReadableAsyncRegisterArray, WriteableAsyncRegisterArray
{%- else -%}
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import Memory, MemoryArray
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import AddressMap
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import RegFile
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib  import AddressMapArray
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib  import RegFileArray
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import MemoryReadOnly{% if legacy_block_access %}Legacy{% endif %}, MemoryWriteOnly{% if legacy_block_access %}Legacy{% endif %}, MemoryReadWrite{% if legacy_block_access %}Legacy{% endif %}
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import MemoryReadOnlyArray, MemoryWriteOnlyArray, MemoryReadWriteArray
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import Reg, RegArray
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import RegReadOnly, RegWriteOnly, RegReadWrite
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import RegReadOnlyArray, RegWriteOnlyArray, RegReadWriteArray
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import FieldReadOnly, FieldWriteOnly, FieldReadWrite, Field
{% if uses_enum %}from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import FieldEnumReadOnly, FieldEnumWriteOnly, FieldEnumReadWrite{% endif %}
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import ReadableRegister, WritableRegister
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import ReadableMemory{% if legacy_block_access %}Legacy{% endif %}, WritableMemory{% if legacy_block_access %}Legacy{% endif %}
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import ReadableRegisterArray, WriteableRegisterArray
{%- endif %}


{% if asyncoutput %}
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import AsyncCallbackSet, AsyncCallbackSetLegacy
{% else %}
from {% if skip_lib_copy %}peakrdl_python.{% else %}..{% endif %}lib import NormalCallbackSet, NormalCallbackSetLegacy
{% endif %}

{% for property_enum in unique_property_enums %}
from .{{top_node.inst_name}}_property_enums import {{property_enum.type_name}}_property_enumcls
{% endfor %}

{%- for node in dependent_registers -%}
from .registers import {{node.python_class_name}}{% if node.instance.is_array %}_array{% endif %}
{% endfor %}

{% from 'addrmap_memory.py.jinja' import memory_class with context %}
{% from 'reg_definitions.py.jinja' import register_class_attributes with context %}
{% from 'addrmap_udp_property.py.jinja' import udp_property with context %}
{% from 'addrmap_universal_property.py.jinja' import universal_properties with context %}
{% from 'addrmap_system_rdl_name_mapping.py.jinja' import get_child_by_system_rdl_name with context %}
{% from 'addrmap_system_rdl_name_mapping.py.jinja' import systemrdl_python_child_name_map with context %}
{% from 'child_definitions.py.jinja' import node_children_iterator with context %}

{%- macro regfile_or_addr_instance(node) %}
    {%- if not hide_node_func(node) %}
    {%- if isinstance(node, systemrdlRegNode) %}
        {{ register_class_attributes(node) }}
    {%- elif isinstance(node, systemrdlMemNode) %}
        {%- if node.is_array %}
    self.__{{node.inst_name}}:{{get_fully_qualified_type_name(node)}}_array = {{get_fully_qualified_type_name(node)}}_array(address=self.address+{{node.raw_address_offset}},
                                                                                  stride={{node.array_stride}},
                                                                                  dimensions=tuple({{node.array_dimensions}}),
                                                                                  logger_handle=logger_handle+'.{{node.inst_name}}',
                                                                                  inst_name='{{node.inst_name}}', parent=self)
        {%- else %}
    self.__{{node.inst_name}}:{{get_fully_qualified_type_name(node)}} = {{get_fully_qualified_type_name(node)}}(
                                                                 address=self.address+{{node.address_offset}},
                                                                 logger_handle=logger_handle+'.{{node.inst_name}}',
                                                                                   inst_name='{{node.inst_name}}', parent=self)
        {%- endif %}
    {%- elif isinstance(node, systemrdlRegfileNode) or isinstance(node, systemrdlAddrmapNode) %}
        {%- if node.is_array %}
    self.__{{node.inst_name}}:{{get_fully_qualified_type_name(node)}}_array = {{get_fully_qualified_type_name(node)}}_array(address=self.address+{{node.raw_address_offset}},
                                                                                  stride={{node.array_stride}},
                                                                                  dimensions=tuple({{node.array_dimensions}}),
                                                                                  logger_handle=logger_handle+'.{{node.inst_name}}',
                                                                                  inst_name='{{node.inst_name}}', parent=self)
        {%- else -%}
    self.__{{node.inst_name}}:{{get_fully_qualified_type_name(node)}} = {{get_fully_qualified_type_name(node)}}(
                                                                            address=self.address+{{node.address_offset}},
                                                                            logger_handle=logger_handle+'.{{node.inst_name}}',
                                                                            inst_name='{{node.inst_name}}',
                                                                            parent=self)
        {%- endif %}
    {%- endif %}
    {%- endif %}
{%- endmacro %}

{%- macro regfile_class(node) %}
class {{node.python_class_name}}({% if asyncoutput %}Async{% endif %}RegFile):
    """
    Class to represent a register file in the register model

    {{get_table_block(node.instance) | indent}}
    """

    __slots__ : list[str] = [{%- for child_node in node.instance.children(unroll=False) -%}'__{{child_node.inst_name}}'{% if not loop.last %}, {% endif %}{%- endfor %}]

    def __init__(self,
                 address: int,
                 logger_handle:str,
                 inst_name:str,
                 parent:Union[{% if asyncoutput %}Async{% endif %}AddressMap,{% if asyncoutput %}Async{% endif %}RegFile]):

        super().__init__(address=address,
                         logger_handle=logger_handle,
                         inst_name=inst_name,
                         parent=parent)

        # instance of objects within the class
        {% for child_node in node.instance.children(unroll=False) -%}
            {{ regfile_or_addr_instance(child_node) | indent }}
        {% endfor %}

    @property
    def size(self) -> int:
        return {{node.instance.size}}

    # properties for Register and RegisterFiles
    {%- for child_node in node.children(unroll=False) %}
        {%- if isinstance(child_node, (systemrdlRegNode, systemrdlRegfileNode)) %}
    @property
    def {{safe_node_name(child_node)}}(self) -> '{% if child_node.is_array -%}{{get_fully_qualified_type_name(child_node)}}_array{% else %}{{get_fully_qualified_type_name(child_node)}}{%- endif -%}':
        """
        Property to access {{child_node.inst_name}} {% if child_node.is_array -%}array{% endif %}

        {{get_table_block(child_node) | indent(8)}}
        """
        return self.__{{child_node.inst_name}}
        {%- endif %}
    {% endfor %}

    {{ systemrdl_python_child_name_map(node.instance) }}

    {{ get_child_by_system_rdl_name(node.instance) }}

    {{ udp_property(node) }}

    {{ universal_properties(node.instance) }}

    {{ node_children_iterator(node) }}

     {%- if node.instance.is_array %}
class {{node.python_class_name}}_array({% if asyncoutput %}Async{% endif %}RegFileArray):
    """
    Class to represent a regfile array in the register model
    """
    __slots__: list[str] = []

    def __init__(self, logger_handle: str, inst_name: str,
                 parent: Union[{% if asyncoutput %}Async{% endif %}AddressMap, {% if asyncoutput %}Async{% endif %}RegFile],
                 address: int,
                 stride: int,
                 dimensions: tuple[int, ...]):

        super().__init__(logger_handle=logger_handle, inst_name=inst_name,
                         parent=parent, address=address,
                         stride=stride, dimensions=dimensions)

    @property
    def _element_datatype(self) -> Type[Node]:
        return {{node.python_class_name}}
    {%- endif %}
{%- endmacro %}

{%- macro addrmap_class(node) %}
class {{node.python_class_name}}({% if asyncoutput %}Async{% endif %}AddressMap):
    """
    Class to represent a address map in the register model

    {{get_table_block(node.instance) | indent}}
    """

    __slots__ : list[str] = [{%- for child_node in node.instance.children(unroll=False) -%}{%- if isinstance(child_node, systemrdlRegNode) or isinstance(child_node, systemrdlRegfileNode) or isinstance(child_node, systemrdlAddrmapNode) or isinstance(child_node, systemrdlMemNode) -%}'__{{child_node.inst_name}}'{% if not loop.last %}, {% endif %}{% endif %}{%- endfor %}]

    def __init__(self, *,
                 address:int {%- if node.instance == top_node -%}={{top_node.absolute_address}}{%- endif -%},
                 logger_handle:str {%- if node.instance == top_node -%}='reg_model.{{top_node.get_path()}}'{%- endif -%},
                 inst_name:str{%- if node.instance == top_node -%}='{{node.instance.inst_name}}'{%- endif -%},
                 callbacks: Optional[Union[{% if asyncoutput %}Async{% else %}Normal{% endif %}CallbackSet, {% if asyncoutput %}Async{% else %}Normal{% endif %}CallbackSetLegacy]]=None,
                 parent:Optional[{% if asyncoutput %}Async{% endif %}AddressMap]=None):

        if callbacks is not None:
            if not isinstance(callbacks, ({% if asyncoutput %}Async{% else %}Normal{% endif %}CallbackSet, {% if asyncoutput %}Async{% else %}Normal{% endif %}CallbackSetLegacy)):
                raise TypeError(f'callbacks should be {% if asyncoutput %}Async{% else %}Normal{% endif %}CallbackSet, {% if asyncoutput %}Async{% else %}Normal{% endif %}CallbackSetLegacy got {type(callbacks)}')

        super().__init__(callbacks=callbacks,
                         address=address,
                         logger_handle=logger_handle,
                         inst_name=inst_name,
                         parent=parent)

        {% for child_node in node.instance.children(unroll=False) -%}
            {{ regfile_or_addr_instance(child_node) | indent }}
        {% endfor %}

    @property
    def size(self) -> int:
        return {{node.instance.size}}

        {%- for child_node in node.children(unroll=False) -%}
            {%- if isinstance(child_node, (systemrdlRegNode, systemrdlRegfileNode, systemrdlAddrmapNode, systemrdlMemNode)) %}
    @property
    def {{safe_node_name(child_node)}}(self) -> '{% if child_node.is_array -%}{{get_fully_qualified_type_name(child_node)}}_array{% else %}{{get_fully_qualified_type_name(child_node)}}{%- endif -%}':
        """
        Property to access {{child_node.inst_name}} {% if child_node.is_array -%}array{% endif %}

        {{get_table_block(child_node) | indent(8)}}
        """
        return self.__{{child_node.inst_name}}
            {%- endif %}
        {% endfor %}

    {{ systemrdl_python_child_name_map(node.instance) }}

    {{ get_child_by_system_rdl_name(node.instance) }}

    {{ udp_property(node) }}

    {{ universal_properties(node.instance) }}

    {{ node_children_iterator(node) }}

    {%- if node.instance.is_array %}
class {{node.python_class_name}}_array({% if asyncoutput %}Async{% endif %}AddressMapArray):
    """
    Class to represent a addrmap array in the register model
    """
    __slots__: list[str] = []

    def __init__(self, logger_handle: str, inst_name: str,
                 parent: {% if asyncoutput %}Async{% endif %}AddressMap,
                 address: int,
                 stride: int,
                 dimensions: tuple[int, ...]):

        super().__init__(logger_handle=logger_handle, inst_name=inst_name,
                         parent=parent, address=address,
                         stride=stride, dimensions=dimensions)

    @property
    def _element_datatype(self) -> Type[Node]:
        return {{node.python_class_name}}
    {%- endif %}
{%- endmacro %}

# addrmap, regfile, memor and register definitions
{%- for unique_node in unique_components -%}
{# the get_dependent_component already strips out hidden items so there is no need to check here
   for hidden items #}
    {% if isinstance(unique_node.instance, systemrdlRegfileNode) %}
    {{ regfile_class(unique_node) }}
    {% elif isinstance(unique_node.instance, systemrdlAddrmapNode) %}
    {{ addrmap_class(unique_node) }}
    {% elif isinstance(unique_node.instance, systemrdlMemNode) %}
    {{ memory_class(unique_node)  }}
    {% else %}
    {{ raise_template_error('Encountered unhandled type') }}
    {% endif %}
{% endfor %}

{{top_node.inst_name}}_cls = {{get_fully_qualified_type_name(top_node)}}

if __name__ == '__main__':
    # dummy functions to demonstrate the class
    {% if asyncoutput %}async {% endif %}def read_addr_space(addr: int, width: int, accesswidth: int) -> int:
        """
        Callback to simulate the operation of the package, everytime the read is called, it will
        request the user input the value to be read back.

        Args:
            addr: Address to write to
            width: Width of the register in bits
            accesswidth: Minimum access width of the register in bits

        Returns:
            value inputted by the used
        """
        assert isinstance(addr, int)
        assert isinstance(width, int)
        assert isinstance(accesswidth, int)
        return int(input('value to read from address:0x%X'%addr))

    {% if asyncoutput %}async {% endif %}def write_addr_space(addr: int, width: int, accesswidth: int, data: int) -> None:
        """
        Callback to simulate the operation of the package, everytime the read is called, it will
        request the user input the value to be read back.

        Args:
            addr: Address to write to
            width: Width of the register in bits
            accesswidth: Minimum access width of the register in bits
            data: value to be written to the register

        Returns:
            None
        """
        assert isinstance(addr, int)
        assert isinstance(width, int)
        assert isinstance(accesswidth, int)
        assert isinstance(data, int)
        print('write data:0x%X to address:0x%X'%(data, addr))

    # create an instance of the class
    {{top_node.inst_name}} = {{top_node.inst_name}}_cls(callbacks = {% if asyncoutput %}AsyncCallbackSet{% else %}NormalCallbackSet{% endif %}{% if legacy_block_access %}Legacy{% endif %}(read_callback=read_addr_space,
                                                                                                     write_callback=write_addr_space))

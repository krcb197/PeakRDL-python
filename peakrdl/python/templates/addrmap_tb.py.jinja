"""
Unit Tests for the {{top_node.inst_name}} register model Python Wrapper

This code was generated from the PeakRDL-python package
"""
import unittest
from unittest.mock import patch
import random
from itertools import combinations


from ..reg_model.{{top_node.type_name}} import {{top_node.type_name}}_cls

def read_addr_space(addr: int):
    assert isinstance(addr, int)
    return 0

def write_addr_space(addr: int, data: int):
    assert isinstance(addr, int)
    assert isinstance(data, int)

def read_callback(addr: int):
    return read_addr_space(addr)

def write_callback(addr: int, data: int):
    write_addr_space(addr, data)


class {{top_node.type_name}}_TestCase(unittest.TestCase):

    def setUp(self):
        self.dut = {{top_node.type_name}}_cls(read_callback=read_callback, write_callback=write_callback)

    @staticmethod
    def _reverse_bits(x: int, n: int) -> int:
        """

        Args:
            x: value to reverse
            n: number of bits used in the value

        Returns:
            reversed valued
        """
        result = 0
        for i in range(n):
            if (x >> i) & 1:
                result |= 1 << (n - 1 - i)
        return result

    def test_addresses_default_baseaddress(self):
        """
        Walk the address map and check the address of every register is correct
        """
        {%- for node in top_node.descendants(unroll=True) -%}
            {%- if isinstance(node, systemrdlRegNode) %}
        self.assertEqual(self.dut.{{'.'.join(node.get_path_segments()[1:])}}.base_address, {{node.absolute_address}})
            {%- endif %}
        {%- endfor %}

    def test_field_properties(self):
        """
        walk the address map and check that the lsb and msb of every field is correct
        """
        {%- for node in top_node.descendants(unroll=True) -%}
            {%- if isinstance(node, systemrdlFieldNode) %}
        # test field properties: {{'.'.join(node.get_path_segments())}}
        self.assertEqual(self.dut.{{'.'.join(node.get_path_segments()[1:])}}.lsb,
                        {{node.lsb}})
        self.assertEqual(self.dut.{{'.'.join(node.get_path_segments()[1:])}}.msb,
                         {{node.msb}})
        self.assertEqual(self.dut.{{'.'.join(node.get_path_segments()[1:])}}.low,
                        {{node.low}})
        self.assertEqual(self.dut.{{'.'.join(node.get_path_segments()[1:])}}.high,
                         {{node.high}})
        self.assertEqual(self.dut.{{'.'.join(node.get_path_segments()[1:])}}.bitmask,
                         {{get_field_bitmask_hex_string(node)}})
        self.assertEqual(self.dut.{{'.'.join(node.get_path_segments()[1:])}}.inverse_bitmask,
                         {{get_field_inv_bitmask_hex_string(node)}})
        self.assertEqual(self.dut.{{'.'.join(node.get_path_segments()[1:])}}.max_value,
                         {{get_field_max_value_hex_string(node)}})
            {%- endif -%}
        {%- endfor %}

    def test_register_read_and_write(self):
        """
        Walk the register map and check every register can be read and written to correctly
        """
        {%- for node in top_node.descendants(unroll=True) -%}
            {%- if isinstance(node, systemrdlRegNode) %}

        # test access operations (read and/or write) to register:
        # {{'.'.join(node.get_path_segments())}}
        with patch(__name__ + '.' + 'write_addr_space') as write_callback_mock, \
            patch(__name__ + '.' + 'read_addr_space', return_value=1) as read_callback_mock:

            {% if node.has_sw_readable -%}
            # test reading back 1 (the unpatched version returns 0 so this confirms the patch works)
            self.assertEqual(self.dut.{{'.'.join(node.get_path_segments()[1:])}}.read(), 1)
            self.assertEqual(read_callback_mock.call_args[0][0], {{node.absolute_address}})  # check address passed to read

            # test the read check with high value
            read_callback_mock.reset_mock()
            read_callback_mock.return_value = {{get_reg_max_value_hex_string(node)}}
            self.assertEqual(self.dut.{{'.'.join(node.get_path_segments()[1:])}}.read(), {{get_reg_max_value_hex_string(node)}})
            read_callback_mock.assert_called_once()

            # test the read of the low value
            read_callback_mock.reset_mock()
            read_callback_mock.return_value = 0
            self.assertEqual(self.dut.{{'.'.join(node.get_path_segments()[1:])}}.read(), 0x0)
            read_callback_mock.assert_called_once()

            # test the read of a random value
            random_value = random.randrange(0, {{get_reg_max_value_hex_string(node)}}+1)
            read_callback_mock.reset_mock()
            read_callback_mock.return_value = random_value
            self.assertEqual(self.dut.{{'.'.join(node.get_path_segments()[1:])}}.read(), random_value)
            read_callback_mock.assert_called_once()

            # at the end of the read tests the write should not have been called
            read_callback_mock.reset_mock()
            write_callback_mock.assert_not_called()
            {% endif %}

            {% if node.has_sw_writable -%}
            # test the write with high value
            self.dut.{{'.'.join(node.get_path_segments()[1:])}}.write({{get_reg_max_value_hex_string(node)}})
            write_callback_mock.assert_called_once()
            self.assertEqual(write_callback_mock.call_args[0][0], {{node.absolute_address}})  # check address passed to read
            self.assertEqual(write_callback_mock.call_args[0][1], {{get_reg_max_value_hex_string(node)}})
            write_callback_mock.reset_mock()

            # test the write of a low value
            self.dut.{{'.'.join(node.get_path_segments()[1:])}}.write(0)
            write_callback_mock.assert_called_once()
            self.assertEqual(write_callback_mock.call_args[0][0], {{node.absolute_address}})  # check address passed to read
            self.assertEqual(write_callback_mock.call_args[0][1], 0)
            write_callback_mock.reset_mock()

            # test the write of a random
            random_value = random.randrange(0, {{get_reg_max_value_hex_string(node)}}+1)
            self.dut.{{'.'.join(node.get_path_segments()[1:])}}.write(random_value)
            write_callback_mock.assert_called_once()
            self.assertEqual(write_callback_mock.call_args[0][0], {{node.absolute_address}})  # check address passed to read
            self.assertEqual(write_callback_mock.call_args[0][1], random_value)
            write_callback_mock.reset_mock()

            # test writting a value beyond the register range is blocked with an exception being raised
            with self.assertRaises(ValueError):
                self.dut.{{'.'.join(node.get_path_segments()[1:])}}.write(-1)

            with self.assertRaises(ValueError):
                self.dut.{{'.'.join(node.get_path_segments()[1:])}}.write({{get_reg_max_value_hex_string(node)}}+1)

            {%- else %}
            # test that a non-writable register has no write method and attempting one generates and error
            with self.assertRaises(AttributeError):
                self.dut.{{'.'.join(node.get_path_segments()[1:])}}.write(0)
            {%- endif %}

            # check the read has not been called in the write test
            read_callback_mock.assert_not_called()
            {%- endif %}
        {%- endfor %}

    def test_int_field_read_and_write(self):
        """
        Check the ability to read and write to integer (non-eumn) fields
        """
    {%- for node in top_node.descendants(unroll=True) -%}
        {%- if isinstance(node, systemrdlFieldNode) %}
        {%- if 'encode' not in node.list_properties() %}

        # test access operations (read and/or write) to field:
        # {{'.'.join(node.get_path_segments())}}
        with patch(__name__ + '.' + 'write_addr_space') as write_callback_mock,\
            patch(__name__ + '.' + 'read_addr_space', return_value=0) as read_callback_mock:

            {% if node.is_sw_readable %}

            # read back - zero, this is achieved by setting the register to inverse bitmask
            read_callback_mock.return_value = {{get_field_inv_bitmask_hex_string(node)}}
            self.assertEqual(self.dut.{{'.'.join(node.get_path_segments()[1:])}}.read(),
                             0)
            read_callback_mock.assert_called_once()

            # read back - max_value, this is achieved by setting the register to bitmask
            read_callback_mock.reset_mock()
            read_callback_mock.return_value = {{get_field_bitmask_hex_string(node)}}
            self.assertEqual(self.dut.{{'.'.join(node.get_path_segments()[1:])}}.read(),
                             {{ get_field_max_value_hex_string(node) }})
            read_callback_mock.assert_called_once()

            # read back - random value
            read_callback_mock.reset_mock()
            random_value = random.randrange(0, {{get_reg_max_value_hex_string(node.parent)}}+1)
            read_callback_mock.return_value = random_value
            random_field_value = (random_value & {{get_field_bitmask_hex_string(node)}}) >> {{node.low}}
            {% if node.msb == node.high -%}
            self.assertEqual(self.dut.{{'.'.join(node.get_path_segments()[1:])}}.read(),
                             random_field_value)
            {% else -%}
            self.assertEqual(self.dut.{{'.'.join(node.get_path_segments()[1:])}}.read(),
                             self._reverse_bits(x=random_field_value, n={{node.width}}))
            {% endif -%}
            read_callback_mock.assert_called_once()

            # at the end of the read tests the write should not have been called
            read_callback_mock.reset_mock()
            write_callback_mock.assert_not_called()
            {%- endif %}

            {%- if node.is_sw_writable %}
            # check the write
            random_reg_value = random.randrange(0, {{get_reg_max_value_hex_string(node.parent)}} + 1)
            random_field_value = random.randrange(0, {{ get_field_max_value_hex_string(node) }} + 1)
            for reg_base_value in [0, {{get_reg_max_value_hex_string(node.parent)}}, random_reg_value]:
                for field_value in [0, {{ get_field_max_value_hex_string(node) }}, random_field_value]:
                    read_callback_mock.reset_mock()
                    write_callback_mock.reset_mock()
                    read_callback_mock.return_value = reg_base_value

                    self.dut.{{'.'.join(node.get_path_segments()[1:])}}.write(field_value)

                    {% if (((node.high+1) - node.low) < (node.parent.size*8)) and (node.parent.has_sw_readable) %}
                    read_callback_mock.assert_called_once()
                    {% else %}
                    read_callback_mock.assert_not_called()
                    {%- endif %}
                    write_callback_mock.assert_called_once()
                    self.assertEqual(write_callback_mock.call_args[0][0],
                                     {{node.parent.absolute_address}})
                    {% if node.parent.has_sw_readable -%}
                    {% if node.msb == node.high -%}
                    self.assertEqual(write_callback_mock.call_args[0][1],
                                     (reg_base_value & {{get_field_inv_bitmask_hex_string(node)}}) | \
                                     ({{get_field_bitmask_hex_string(node)}} & (field_value << {{node.low}})))
                    {% else -%}
                    self.assertEqual(write_callback_mock.call_args[0][1],
                                     (reg_base_value & {{get_field_inv_bitmask_hex_string(node)}}) | \
                                     ({{get_field_bitmask_hex_string(node)}} & (self._reverse_bits(x=field_value, n={{node.width}}) << {{node.low}})))
                    {% endif -%}
                    {% else -%}
                    # if the register is not readable, the value is simply written
                    {% if node.msb == node.high -%}
                    self.assertEqual(write_callback_mock.call_args[0][1],
                                     field_value << {{node.low}})
                    {% else -%}
                    self.assertEqual(write_callback_mock.call_args[0][1],
                                     self._reverse_bits(x=field_value, n={{node.width}}) << {{node.low}})
                    {% endif -%}
                    {% endif %}

            # check invalid write values bounce
            with self.assertRaises(ValueError):
                self.dut.{{'.'.join(node.get_path_segments()[1:])}}.write({{ get_field_max_value_hex_string(node) }} + 1)

            with self.assertRaises(ValueError):
                self.dut.{{'.'.join(node.get_path_segments()[1:])}}.write(-1)
            {%- endif %}

        {%- endif %}
        {%- endif %}
    {%- endfor %}

    {% if uses_enum %}
    def test_enum_field_read_and_write(self):
        """
        Check the ability to read and write to enum fields
        """
    {%- for node in top_node.descendants(unroll=True) -%}
        {%- if isinstance(node, systemrdlFieldNode) %}
        {%- if 'encode' in node.list_properties() %}

        # test access operations (read and/or write) to field:
        # {{'.'.join(node.get_path_segments())}}
        with patch(__name__ + '.' + 'write_addr_space') as write_callback_mock,\
            patch(__name__ + '.' + 'read_addr_space', return_value=0) as read_callback_mock:

            {% if node.is_sw_readable %}
            # read back test
            {%- for value_of_enum_needed in node.get_property('encode') -%}
            # set the simulated read_back value to {{value_of_enum_needed.name}}
            random_reg_value = random.randrange(0, {{get_reg_max_value_hex_string(node.parent)}} + 1)
            read_callback_mock.reset_mock()
            {% if node.msb == node.high -%}
            read_callback_mock.return_value = (random_reg_value & {{get_field_inv_bitmask_hex_string(node)}}) | \
                                              ({{get_field_bitmask_hex_string(node)}} & ({{value_of_enum_needed.value}} << {{node.low}} ))
            {% else -%}
            read_callback_mock.return_value = (random_reg_value & {{get_field_inv_bitmask_hex_string(node)}}) | \
                                              ({{get_field_bitmask_hex_string(node)}} & (self._reverse_bits(x={{value_of_enum_needed.value}}, n={{node.width}}) << {{node.low}} ))
            {% endif -%}

            self.assertEqual(self.dut.{{'.'.join(node.get_path_segments()[1:])}}.read(),
                             self.dut.{{'.'.join(node.get_path_segments()[1:])}}.enum_cls.{{value_of_enum_needed.name}})
            read_callback_mock.assert_called_once()
            {% endfor %}

            {% if node.get_property('encode').__len__() < (2**((node.high+1) - node.low)) %}
            # check that other values of the field int
            # that don't appear in the enum generate an
            # error
            for field_value in range(0, {{get_field_max_value_hex_string(node)}}+1):
                if field_value in [{%- for value_of_enum_needed in node.get_property('encode') -%}{{value_of_enum_needed.value}}{% if not loop.last %}, {% endif %}{%- endfor %}]:
                    # legal int value of the eunm so no test is needed
                    continue
                with self.assertRaises(ValueError):
                    read_callback_mock.reset_mock()
                    random_reg_value = random.randrange(0, {{get_reg_max_value_hex_string(node.parent)}} + 1)
                    {% if node.msb == node.high -%}
                    read_callback_mock.return_value = (random_reg_value & {{get_field_inv_bitmask_hex_string(node)}}) | \
                                     ({{get_field_bitmask_hex_string(node)}} & (field_value << {{node.low}}))
                    {% else -%}
                    read_callback_mock.return_value = (random_reg_value & {{get_field_inv_bitmask_hex_string(node)}}) | \
                                     ({{get_field_bitmask_hex_string(node)}} & (self._reverse_bits(x=field_value, n={{node.width}}) << {{node.low}}))
                    {% endif -%}
                    decode_field_value = self.dut.{{'.'.join(node.get_path_segments()[1:])}}.read()
            {% endif %}
            write_callback_mock.assert_not_called()
            {% endif %}

            {% if node.is_sw_writable %}
            enum_cls = self.dut.{{'.'.join(node.get_path_segments()[1:])}}.enum_cls
            {% for value_of_enum_needed in node.get_property('encode') %}
            random_reg_value = random.randrange(0, {{get_reg_max_value_hex_string(node.parent)}} + 1)
            read_callback_mock.reset_mock()
            write_callback_mock.reset_mock()
            read_callback_mock.return_value = random_reg_value

            self.dut.{{'.'.join(node.get_path_segments()[1:])}}.write(enum_cls.{{value_of_enum_needed.name}})

            {% if ( node.width < (node.parent.size*8)) and (node.parent.has_sw_readable) %}
            read_callback_mock.assert_called_once()
            {% else %}
            read_callback_mock.assert_not_called()
            {%- endif %}

            write_callback_mock.assert_called_once()
            self.assertEqual(write_callback_mock.call_args[0][0],
                             {{node.parent.absolute_address}})
            {% if node.parent.has_sw_readable -%}
            {% if node.msb == node.high -%}
            self.assertEqual(write_callback_mock.call_args[0][1],
                             (random_reg_value & {{get_field_inv_bitmask_hex_string(node)}}) | \
                             ({{get_field_bitmask_hex_string(node)}} & ({{value_of_enum_needed.value}} << {{node.low}})))
            {% else -%}
            self.assertEqual(write_callback_mock.call_args[0][1],
                             (random_reg_value & {{get_field_inv_bitmask_hex_string(node)}}) | \
                             ({{get_field_bitmask_hex_string(node)}} & (self._reverse_bits(x={{value_of_enum_needed.value}}, n={{node.width}}) << {{node.low}})))
            {% endif -%}
            {% else -%}
            # if the register is not readable, the value is simply written
            {% if node.msb == node.high -%}
            self.assertEqual(write_callback_mock.call_args[0][1],
                             {{value_of_enum_needed.value}} << {{node.low}})
            {% else -%}
            self.assertEqual(write_callback_mock.call_args[0][1],
                             self._reverse_bits(x={{value_of_enum_needed.value}}, n={{node.width}}) << {{node.low}})
            {% endif -%}
            {% endif %}

            {% endfor %}
            {% endif %}

        {%- endif %}
        {%- endif %}
    {%- endfor %}
    {%- endif %}

    def test_register_read_fields(self):
        """
        Walk the register map and check every register read_fields method
        """
        {%- for node in top_node.descendants(unroll=True) -%}
        {%- if isinstance(node, systemrdlRegNode) %}
        {% if node.has_sw_readable %}
        # test read_fields to register:
        # {{'.'.join(node.get_path_segments())}}
        # build up the register value with a random base value, overlaid with
        # a random value for each field
        rand_reg_value = random.randrange(0, {{get_reg_max_value_hex_string(node)}} + 1)
        {%- for field in node.children() %}
        {%- if field.is_sw_readable -%}
        {%- if 'encode' in field.list_properties() %}
        rand_field_value = random.choice(list(self.dut.{{'.'.join(field.get_path_segments()[1:])}}.enum_cls)).value
        {%- else %}
        rand_field_value = random.randrange(0, {{ get_field_max_value_hex_string(field) }} + 1)
        {%- endif %}
        {% if field.msb == field.high -%}
        rand_reg_value = (rand_reg_value & {{get_field_inv_bitmask_hex_string(field)}}) | (rand_field_value << {{ field.low }})
        {% else -%}
        rand_reg_value = (rand_reg_value & {{get_field_inv_bitmask_hex_string(field)}}) | (self._reverse_bits(x=rand_field_value, n={{field.width}}) << {{ field.low }})
        {% endif -%}
        {%- endif %}
        {% endfor %}
        with patch(__name__ + '.' + 'read_addr_space', return_value=rand_reg_value):
            # the read_fields method gets a dictionary back
            # from the object with all the read back field
            # values
            reference_read_fields = { {% for field in node.children() -%}
                                      {%- if field.is_sw_readable %}
                                      '{{ field.inst_name }}' : self.dut.{{'.'.join(field.get_path_segments()[1:])}}.read(){%- if not loop.last -%}, {%- endif %}
                                      {%- endif -%}
                                      {%- endfor %}
                                    }

            self.assertDictEqual(self.dut.{{'.'.join(node.get_path_segments()[1:])}}.read_fields(),
                                 reference_read_fields)

        {%- endif %}
        {%- endif %}
        {%- endfor %}

    def test_register_write_fields(self):
        """
        Walk the register map and check every register write_fields method
        """
        def write_field_cominbinations(reg, writable_fields):
            with patch(__name__ + '.' + 'write_addr_space') as write_callback_mock, \
                patch(__name__ + '.' + 'read_addr_space', return_value=0) as read_callback_mock:
                for num_parm in range(1, len(writable_fields) + 1):
                    for fields_to_write in combinations(writable_fields, num_parm):
                        kwargs = {}
                        expected_value = 0
                        for field_str in fields_to_write:
                            field = getattr(reg, field_str)
                            if hasattr(field, 'enum_cls'):
                                rand_enum_value = random.choice(list(field.enum_cls))
                                rand_field_value = rand_enum_value.value
                                kwargs[field_str] = rand_enum_value
                            else:
                                rand_field_value = random.randrange(0, field.max_value + 1)
                                kwargs[field_str] = rand_field_value

                            if field.msb == field.high:
                                expected_value = ( expected_value & field.inverse_bitmask ) | (rand_field_value << field.low)
                            elif field.msb == field.low:
                                expected_value = ( expected_value & field.inverse_bitmask ) | (self._reverse_bits(x=rand_field_value, n=field.width) << field.low)
                            else:
                                raise RuntimeError('invalid msb/lsb high/low combination')

                        reg.write_fields(**kwargs)
                        write_callback_mock.assert_called_once()
                        self.assertEqual(write_callback_mock.call_args[0][0],
                                         reg.base_address)
                        self.assertEqual(write_callback_mock.call_args[0][1],expected_value)
                        read_callback_mock.assert_called_once()
                        write_callback_mock.reset_mock()
                        read_callback_mock.reset_mock()


        {%- for node in top_node.descendants(unroll=True) -%}
        {%- if isinstance(node, systemrdlRegNode) %}
        {% if node.has_sw_writable %}
        # test read_fields to register:
        # {{'.'.join(node.get_path_segments())}}


        {% if node.has_sw_readable %}
        write_field_cominbinations(reg=self.dut.{{'.'.join(node.get_path_segments()[1:])}},
                                   writable_fields = [ {% for field in get_reg_writable_fields(node) -%}
                                                       '{{ field.inst_name }}' {%- if not loop.last -%},{%- endif %}
                                                       {% endfor -%} ])
        {% else %}
        kwargs = {}
        expected_value = 0
        {% for field in get_reg_writable_fields(node) %}
        {%- if 'encode' in field.list_properties() %}
        rand_enum_value = random.choice(list(self.dut.{{'.'.join(field.get_path_segments()[1:])}}.enum_cls))
        rand_field_value = rand_enum_value.value
        kwargs['{{field.inst_name}}'] = rand_enum_value
        {%- else %}
        rand_field_value = random.randrange(0, {{ get_field_max_value_hex_string(field) }} + 1)
        kwargs['{{field.inst_name}}'] = rand_field_value
        {%- endif  %}
        expected_value = ( expected_value & {{get_field_inv_bitmask_hex_string(field)}} ) | (rand_field_value << {{ field.low }})
        {% endfor %}
        with patch(__name__ + '.' + 'write_addr_space') as write_callback_mock, \
            patch(__name__ + '.' + 'read_addr_space', return_value=0) as read_callback_mock:
            self.dut.{{'.'.join(node.get_path_segments()[1:])}}.write_fields(**kwargs)
            write_callback_mock.assert_called_once()
            read_callback_mock.assert_not_called
            self.assertEqual(write_callback_mock.call_args[0][0],
                             {{node.absolute_address}})
            self.assertEqual(write_callback_mock.call_args[0][1],expected_value)
            write_callback_mock.reset_mock()
            read_callback_mock.reset_mock()

        {% endif %}


        {%- endif %}
        {%- endif %}
        {%- endfor %}




if __name__ == '__main__':
    unittest.main()




